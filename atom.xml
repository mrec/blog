<?xml version="1.0" encoding="UTF-8"?>
<feed xmlns="http://www.w3.org/2005/Atom" xml:lang="en">
    <title>Never Knowingly Undershaved</title>
    <subtitle>Probably programming-related, definitely stupidly-titled</subtitle>
    <link rel="self" type="application/atom+xml" href="https://mrec.github.io/blog/atom.xml"/>
    <link rel="alternate" type="text/html" href="https://mrec.github.io/blog/"/>
    <generator uri="https://www.getzola.org/">Zola</generator>
    <updated>2025-07-14T00:00:00+00:00</updated>
    <id>https://mrec.github.io/blog/atom.xml</id>
    <entry xml:lang="en">
        <title>`text-shadow` and accessibility checking</title>
        <published>2025-07-03T00:00:00+00:00</published>
        <updated>2025-07-14T00:00:00+00:00</updated>
        
        <author>
          <name>
            
              Mike Capp
            
          </name>
        </author>
        
        <link rel="alternate" type="text/html" href="https://mrec.github.io/blog/2025/text-shadow/"/>
        <id>https://mrec.github.io/blog/2025/text-shadow/</id>
        
        <content type="html" xml:base="https://mrec.github.io/blog/2025/text-shadow/">&lt;p&gt;Current accessibility tools have significant gaps in how they handle &lt;a class=&quot;external&quot; rel=&quot;nofollow noreferrer&quot; href=&quot;https:&#x2F;&#x2F;developer.mozilla.org&#x2F;en-US&#x2F;docs&#x2F;Web&#x2F;CSS&#x2F;text-shadow&quot;&gt;&lt;code&gt;text-shadow&lt;&#x2F;code&gt;&lt;&#x2F;a&gt; when checking contrast. Some ignore shadows entirely, others handle them well in simple cases but give up when backgrounds get complex. This post explores the issues involved, outlines two broad approaches taken by current tools, and demonstrates potential improvements to both with a working proof-of-concept. There’s no silver bullet – it’s an inherently messy problem – but incremental progress is possible.&lt;&#x2F;p&gt;
&lt;p&gt;It’s amazing how effective yak-shaving can be for leading you to &lt;del&gt;absurdly niche&lt;&#x2F;del&gt; under-explored areas. At the time of writing, the top right of this blog’s header showed the blog name in white letters overlaid on a background image including both landscape (dark-to-medium brightness) and sky (light). Since white-on-light isn’t great for contrast, I’d added a text shadow effect providing a darker halo around the letters. I didn’t think much more about it until I ran the accessibility checker built into Firefox’s excellent developer tools, which delivered the damning verdict &lt;em&gt;“Does not meet WCAG standards for accessible text”&lt;&#x2F;em&gt;, with a best-case colour swatch strongly suggesting that the tool wasn’t paying any attention at all to the shadow specifically intended to improve contrast. &lt;a class=&quot;external&quot; rel=&quot;nofollow noreferrer&quot; href=&quot;https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Lighthouse_(software)&quot;&gt;Lighthouse&lt;&#x2F;a&gt; (the corresponding tool in Chromium-based browsers) raised no such objection, but continued to raise no objection even without the shadow, which cast some doubts upon its rigour. Oh well, just one of those trifling disappointments which build character, and certainly nothing to warrant an obsessive overreac–&lt;&#x2F;p&gt;
&lt;p&gt;&lt;img src=&quot;https:&#x2F;&#x2F;mrec.github.io&#x2F;blog&#x2F;2025&#x2F;text-shadow&#x2F;pepe_silvia.webp&quot; alt=&quot;‘Pepe Silvia’ meme showing a crazed conspiracy loon in front of his theory wall&quot; title=&quot;Oh dear&quot; &#x2F;&gt;&lt;&#x2F;p&gt;
&lt;p&gt;We’ll start with general background, then survey some of the perceptual considerations that make this area such a challenge to model. From there we’ll get into the technical weeds, exploring the analytic and image-based approaches used by Lighthouse and Firefox respectively, and describing ideas implemented in the working proof-of-concept. These sections include some code, but it’s not essential for understanding the core ideas.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;background&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#background&quot; aria-label=&quot;Anchor link for: background&quot;&gt;Background&lt;&#x2F;a&gt;&lt;&#x2F;h2&gt;
&lt;p&gt;Accessibility checkers are tools designed to help developers make their UIs as usable as possible for people with various disabilities, including difficulties distinguishing differences in brightness and colour. The Firefox accessibility tool has a nifty “Simulate” tool where you can get a sense of what this looks like in practice; it can also run an audit of your page to try to catch some common issues, like the one that prompted this post. This was
WCAG’s &lt;a class=&quot;external&quot; rel=&quot;nofollow noreferrer&quot; href=&quot;https:&#x2F;&#x2F;w3c.github.io&#x2F;wcag&#x2F;guidelines&#x2F;22&#x2F;#contrast-minimum&quot;&gt;Contrast (Minimum)&lt;&#x2F;a&gt; rule, which wants a contrast of at least 4.5:1 for normal text or 3:1 for large text.&lt;&#x2F;p&gt;
&lt;details&gt;
&lt;summary&gt;That rule exempts text &lt;em&gt;‘that is part of a logo or brand name’&lt;&#x2F;em&gt;. Isn’t this sort of a logotype?&lt;&#x2F;summary&gt;
&lt;p&gt;That would be a stretch; the text serves as a hyperlink to the blog’s homepage, so it’s not purely decorative. More to the point, there’s no way to mark an element as “part of a logo or brand name”, which makes the question kind of moot.&lt;&#x2F;p&gt;
&lt;&#x2F;details&gt;
&lt;p&gt;The WCAG rule is notably vague on what’s being contrasted with what. Normally it’ll just be text colour against background colour, which is easy to validate, but there are also more complicated possibilities:&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;The background is an image or gradient rather than a flat colour&lt;&#x2F;li&gt;
&lt;li&gt;The text has a CSS &lt;a class=&quot;external&quot; rel=&quot;nofollow noreferrer&quot; href=&quot;https:&#x2F;&#x2F;developer.mozilla.org&#x2F;en-US&#x2F;docs&#x2F;Web&#x2F;CSS&#x2F;text-shadow&quot;&gt;&lt;code&gt;text-shadow&lt;&#x2F;code&gt;&lt;&#x2F;a&gt; effect applied, often specifically to improve contrast&lt;&#x2F;li&gt;
&lt;li&gt;The text has an outline in a different colour, drawn with the new and still vendor-prefixed but nevertheless widely-supported CSS &lt;a class=&quot;external&quot; rel=&quot;nofollow noreferrer&quot; href=&quot;https:&#x2F;&#x2F;developer.mozilla.org&#x2F;en-US&#x2F;docs&#x2F;Web&#x2F;CSS&#x2F;-webkit-text-stroke&quot;&gt;&lt;code&gt;-webkit-text-stroke&lt;&#x2F;code&gt;&lt;&#x2F;a&gt; property&lt;&#x2F;li&gt;
&lt;li&gt;The text is shown superimposed over some arbitrary other content, e.g. using &lt;code&gt;position: absolute&lt;&#x2F;code&gt; or just poorly-managed overflow&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;This post is mainly interested in the second of these, but they’re all worth keeping in mind and will come up again. One complication I’m not going to cover here is partially-transparent text colour; mildly interesting, but it’s straightforwardly bad for contrast and doesn’t have a lot in common with our main focus. I’m also not considering the important caveat that layout shifts might move text onto a different background; as far as I know, all checkers only consider a snapshot of layout and can’t simulate possible changes to it.&lt;&#x2F;p&gt;
&lt;details&gt;
&lt;summary&gt;What about CSS rules specifically targeting low-vision users?&lt;&#x2F;summary&gt;
&lt;p&gt;CSS has a recent &lt;code&gt;@media&lt;&#x2F;code&gt; feature called &lt;a class=&quot;external&quot; rel=&quot;nofollow noreferrer&quot; href=&quot;https:&#x2F;&#x2F;developer.mozilla.org&#x2F;en-US&#x2F;docs&#x2F;Web&#x2F;CSS&#x2F;@media&#x2F;prefers-contrast&quot;&gt;&lt;code&gt;prefers-contrast&lt;&#x2F;code&gt;&lt;&#x2F;a&gt;, which allows stylesheet authors to enable special rules for users who need more contrast. In the case of our header, we could do something like slapping a big black box under the link text:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;css&quot; style=&quot;background-color:#ffffff;color:#000000;&quot; class=&quot;language-css &quot;&gt;&lt;code class=&quot;language-css&quot; data-lang=&quot;css&quot;&gt;&lt;span style=&quot;color:#9062a1;&quot;&gt;@media &lt;&#x2F;span&gt;&lt;span&gt;(prefers-contrast: more) { &lt;&#x2F;span&gt;&lt;span style=&quot;font-style:italic;color:#3c802c;&quot;&gt;&#x2F;* replace with no-preference to test *&#x2F;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#291fb7;&quot;&gt;header a &lt;&#x2F;span&gt;&lt;span&gt;{ background-color: #000a; box-shadow: 0 0 0.5&lt;&#x2F;span&gt;&lt;span style=&quot;color:#9062a1;&quot;&gt;em &lt;&#x2F;span&gt;&lt;span&gt;#000a; }
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;With a rule like that in effect, checkers are happy. Unfortunately, in the normal course of things, checkers don’t simulate this preference being enabled when assessing contrast. There’s an argument to be made that they &lt;em&gt;should&lt;&#x2F;em&gt;, and there’s a &lt;a class=&quot;external&quot; rel=&quot;nofollow noreferrer&quot; href=&quot;https:&#x2F;&#x2F;bugzilla.mozilla.org&#x2F;show_bug.cgi?id=1934406&quot;&gt;Bugzilla ticket&lt;&#x2F;a&gt; you can follow if you agree. I’m ambivalent; the rationale makes sense, but I can also imagine cases where the user doesn’t know about the preference, or is using someone else’s computer where they don’t feel comfortable messing with settings, or a browser running in kiosk mode where the settings aren’t physically accessible.&lt;&#x2F;p&gt;
&lt;&#x2F;details&gt;
&lt;h2 id=&quot;perceptual-considerations&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#perceptual-considerations&quot; aria-label=&quot;Anchor link for: perceptual-considerations&quot;&gt;Perceptual considerations&lt;&#x2F;a&gt;&lt;&#x2F;h2&gt;
&lt;p&gt;The &lt;code&gt;text-shadow&lt;&#x2F;code&gt; property description is deceptively simple. There are only really three knobs to twiddle: the colour of the shadow, the offset of the shadow from the text generating it, and the blur radius (formally related to the size of the convolution matrix used by the effect’s &lt;a class=&quot;external&quot; rel=&quot;nofollow noreferrer&quot; href=&quot;https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Gaussian_blur&quot;&gt;Gaussian blur&lt;&#x2F;a&gt;; informally, how much the shadow is diffuse rather than hard-edged). There’s also a fourth factor, which is that multiple shadows can be declared in the same CSS rule, potentially with different colour&#x2F;offset&#x2F;radius settings.&lt;&#x2F;p&gt;
&lt;p&gt;The interaction of these factors, though, makes the impact of shadows on legibility a non-trivial thing to model. Not &lt;a class=&quot;external&quot; rel=&quot;nofollow noreferrer&quot; href=&quot;https:&#x2F;&#x2F;manishearth.github.io&#x2F;blog&#x2F;2017&#x2F;08&#x2F;10&#x2F;font-size-an-unexpectedly-complex-css-property&#x2F;&quot;&gt;&lt;code&gt;font-size&lt;&#x2F;code&gt; levels of nontrivial&lt;&#x2F;a&gt; by any means, but nontrivial.&lt;&#x2F;p&gt;
&lt;p&gt;Colour is the simplest. Text shadows tend to be weak at best, so I’m not considering fractional alpha. However, don’t assume that a shadow necessarily &lt;em&gt;helps&lt;&#x2F;em&gt; contrast. When the “shadow” colour is closer to the foreground than the background, like a glow effect to make light text appear even brighter, it effectively blurs the edges making it less readable:&lt;&#x2F;p&gt;
&lt;p&gt;&lt;a class=&quot;external&quot; rel=&quot;nofollow noreferrer&quot; href=&quot;https:&#x2F;&#x2F;mrec.github.io&#x2F;webtoys&#x2F;masked_contrast&#x2F;#!d4gnr&quot;&gt;&lt;img src=&quot;https:&#x2F;&#x2F;mrec.github.io&#x2F;blog&#x2F;2025&#x2F;text-shadow&#x2F;glow.webp&quot; alt=&quot;text with a glow effect harming legibility&quot; &#x2F;&gt;&lt;&#x2F;a&gt;&lt;&#x2F;p&gt;
&lt;p&gt;Offset is technically two offsets, &lt;code&gt;x&lt;&#x2F;code&gt; and &lt;code&gt;y&lt;&#x2F;code&gt;. For shadows aiming to enhance contrast it’ll usually make sense to offset on both axes; a vertical-only offset won’t do much to enhance the legibility of a sans-serif ‘I’, or a horizontal-only one of an em dash. A zero offset in the absence of any blur means the shadow will be invisible behind its text, making it useless. Excessive offsets hurt legibility more than they help; in extreme cases they may not even be onscreen, but even slightly too high and they can start to separate shadows from their parent glyphs or overlap neigbouring glyphs.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;a class=&quot;external&quot; rel=&quot;nofollow noreferrer&quot; href=&quot;https:&#x2F;&#x2F;mrec.github.io&#x2F;webtoys&#x2F;masked_contrast&#x2F;#!d1exn&quot;&gt;&lt;img src=&quot;https:&#x2F;&#x2F;mrec.github.io&#x2F;blog&#x2F;2025&#x2F;text-shadow&#x2F;over_offset.webp&quot; alt=&quot;text with a slightly excessive offset&quot; &#x2F;&gt;&lt;&#x2F;a&gt;&lt;&#x2F;p&gt;
&lt;p&gt;Blur radius is the only optional part of the property, defaulting to zero. (This may just reflect the fact that Gaussian blurs are relatively expensive operations, not feasible on old or low-end hardware.) Small radii give a more tightly-defined shadow but may be so thin as to be imperceptible; with no offset, most of the glyph pixels covered by the blur kernel just end up contributing shadow to pixels hidden under the same glyph. Larger radii give a larger halo, but at the cost of diluting the shadow contribution and so providing weaker contrast.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;a class=&quot;external&quot; rel=&quot;nofollow noreferrer&quot; href=&quot;https:&#x2F;&#x2F;mrec.github.io&#x2F;webtoys&#x2F;masked_contrast&#x2F;#!d1ent&quot;&gt;&lt;img src=&quot;https:&#x2F;&#x2F;mrec.github.io&#x2F;blog&#x2F;2025&#x2F;text-shadow&#x2F;under_blur.webp&quot; alt=&quot;text with insufficient blur&quot; &#x2F;&gt;&lt;&#x2F;a&gt;
&lt;a class=&quot;external&quot; rel=&quot;nofollow noreferrer&quot; href=&quot;https:&#x2F;&#x2F;mrec.github.io&#x2F;webtoys&#x2F;masked_contrast&#x2F;#!d1enx&quot;&gt;&lt;img src=&quot;https:&#x2F;&#x2F;mrec.github.io&#x2F;blog&#x2F;2025&#x2F;text-shadow&#x2F;over_blur.webp&quot; alt=&quot;text with excessive blur&quot; &#x2F;&gt;&lt;&#x2F;a&gt;&lt;&#x2F;p&gt;
&lt;p&gt;Slightly surprisingly, a small offset on its own can be perceptually just as effective as a small blur on its own, despite only providing contrast along one side of a glyph. I think this is because it’s a stronger contrast, with alpha undiluted by blurring, and because essentially all writing systems are fundamentally made up of lines. (Braille is the only major exception, and not relevant to a discussion of visual contrast.) Solid glyph shapes are just embellishments; it’s less important to see all the edges of a shape faintly than to see all the core lines clearly. There are pitfalls here, though: any single offset direction is likely to leave some lines without contrast; for a typical diagonal offset, half of ‘x’ is likely to suffer. And to be clear, this is not &lt;em&gt;good&lt;&#x2F;em&gt; contrast! It’s just better than nothing, and ought to be recognized as such.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;a class=&quot;external&quot; rel=&quot;nofollow noreferrer&quot; href=&quot;https:&#x2F;&#x2F;mrec.github.io&#x2F;webtoys&#x2F;masked_contrast&#x2F;#!d1etn&quot;&gt;&lt;img src=&quot;https:&#x2F;&#x2F;mrec.github.io&#x2F;blog&#x2F;2025&#x2F;text-shadow&#x2F;offset_only.webp&quot; alt=&quot;surprisingly legible text only offset only&quot; &#x2F;&gt;&lt;&#x2F;a&gt;&lt;&#x2F;p&gt;
&lt;p&gt;With both offset and blur combined, the perceptual sweet spot seems to be to have the centre of each shadow line, the most opaque part, displaced to the edge of its glyph line, while blur is just sufficient to provide some contrast to the other side of the stem without diluting the shadow too much.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;a class=&quot;external&quot; rel=&quot;nofollow noreferrer&quot; href=&quot;https:&#x2F;&#x2F;mrec.github.io&#x2F;webtoys&#x2F;masked_contrast&#x2F;#!d2etr&quot;&gt;&lt;img src=&quot;https:&#x2F;&#x2F;mrec.github.io&#x2F;blog&#x2F;2025&#x2F;text-shadow&#x2F;sweet_spot.webp&quot; alt=&quot;sweet spot with moderate offset and blur&quot; &#x2F;&gt;&lt;&#x2F;a&gt;&lt;&#x2F;p&gt;
&lt;p&gt;The most common use of multiple shadows is to stack the same definition several times, to support a larger blur while still accumulating enough alpha to be effective. I’m assuming this for the sake of simplicity. Other more artistic patterns are possible, but rare. Lighthouse considers one interesting case, that of multiple thin (tiny offset, little or no blur) shadows stacked at slightly different offsets to approximate the effect of an outline stroke. This may have been common practice before blurs were widely supported, but these days a few clone shadows stacked with tiny blur and no offset can produce a similar but smoother effect, or for larger font sizes the new &lt;code&gt;-webkit-text-stroke&lt;&#x2F;code&gt; can support the desired text stroke directly.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;a class=&quot;external&quot; rel=&quot;nofollow noreferrer&quot; href=&quot;https:&#x2F;&#x2F;mrec.github.io&#x2F;webtoys&#x2F;masked_contrast&#x2F;#!d4ens&quot;&gt;&lt;img src=&quot;https:&#x2F;&#x2F;mrec.github.io&#x2F;blog&#x2F;2025&#x2F;text-shadow&#x2F;fake_stroke.webp&quot; alt=&quot;tight heavy shadow simulating stroked text&quot; &#x2F;&gt;&lt;&#x2F;a&gt;&lt;&#x2F;p&gt;
&lt;details&gt;
&lt;summary&gt;A digression on stroked text, and becoming too fixated on implementation distinctions&lt;&#x2F;summary&gt;
&lt;p&gt;One thought that kept recurring toward the end of writing this post is that “foreground versus background” can be a rather arbitrary distinction. Note 5 under &lt;a class=&quot;external&quot; rel=&quot;nofollow noreferrer&quot; href=&quot;https:&#x2F;&#x2F;www.w3.org&#x2F;TR&#x2F;WCAG21&#x2F;#dfn-contrast-ratio&quot;&gt;WCAG21’s contrast definition&lt;&#x2F;a&gt; is a prime example:&lt;&#x2F;p&gt;
&lt;blockquote&gt;
&lt;p&gt;When there is a border around the letter, the border can add contrast and would be used in calculating the contrast between the letter and its background. A narrow border around the letter would be used as the letter. A wide border around the letter that fills in the inner details of the letters acts as a halo and would be considered background.&lt;&#x2F;p&gt;
&lt;&#x2F;blockquote&gt;
&lt;p&gt;As we’ve come to expect there’s no clear definition of “narrow” or “wide”, but the more pernicious bit here is &lt;em&gt;“[a] narrow border around the letter would be used as the letter”&lt;&#x2F;em&gt;. This is talking about &lt;code&gt;-webkit-text-stroke&lt;&#x2F;code&gt; or thin-shadow approximations thereof, and I think it’s misleading because it misses how these enhancements work. They’re effective because with a thinly-stroked outline, both the stroke colour &lt;em&gt;and&lt;&#x2F;em&gt; the fill colour can provide useful contrast. If I have white text over a mostly dark background, it doesn’t suddenly become unreadable when I add a black stroke. That just offers a fallback route to contrast in case patches of the background are lighter. In this case I think the analysis should calculate all three contrasts in play – stroke&#x2F;background, fill&#x2F;background, and stroke&#x2F;fill – and use the best of them.&lt;&#x2F;p&gt;
&lt;p&gt;Another example: text softened by a &lt;code&gt;filter: blur&lt;&#x2F;code&gt; would generally be considered to be all foreground, whereas a stacked text shadow in the text colour is considered background, despite the two routes potentially rendering the exact same final pixels.&lt;&#x2F;p&gt;
&lt;&#x2F;details&gt;
&lt;details&gt;
&lt;summary&gt;On the silliness of stacking Gaussian blurs&lt;&#x2F;summary&gt;
&lt;p&gt;The ubiquity of multiple stacked copies as the solution to overly watery &lt;code&gt;text-shadow&lt;&#x2F;code&gt;s has become something of a pet peeve over the course of looking into this topic. As mentioned before, a Gaussian blur is &lt;em&gt;expensive&lt;&#x2F;em&gt;, and multiple identical blurs multiply that expense. It would seem to make far more sense to support a simple saturating alpha multiplier that could achieve the same result with only a single blur and a fraction of the cost.&lt;&#x2F;p&gt;
&lt;p&gt;This is something that a Sufficiently Smart Browser could theoretically optimize behind the scenes, but I don’t know if any do. And the intent of an explicit multiplier would be far clearer in the CSS than reading a half-dozen shadow definitions and checking that they’re all the same.&lt;&#x2F;p&gt;
&lt;&#x2F;details&gt;
&lt;h2 id=&quot;moving-on-to-implementation&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#moving-on-to-implementation&quot; aria-label=&quot;Anchor link for: moving-on-to-implementation&quot;&gt;Moving on to implementation&lt;&#x2F;a&gt;&lt;&#x2F;h2&gt;
&lt;p&gt;So if those are some of the major considerations, how might we deal with them? There are two main paths: the analytic approach, which only looks at the styled (&lt;code&gt;getComputedStyle()&lt;&#x2F;code&gt;) DOM tree, and the image-based approach, which looks at the actual pixels getting rendered. Both Firefox and Lighthouse do the former in simple cases, with Lighthouse taking it further in the specific &lt;code&gt;text-shadow&lt;&#x2F;code&gt; case. To the best of my knowledge, only Firefox does image-based assessment; I’m not sure that Lighthouse’s architecture would even allow it, since it’s less tightly coupled with the browser.&lt;&#x2F;p&gt;
&lt;p&gt;This post was written side by side with a basic proof-of-concept demo, which you can see &lt;a class=&quot;external&quot; rel=&quot;nofollow noreferrer&quot; href=&quot;https:&#x2F;&#x2F;mrec.github.io&#x2F;webtoys&#x2F;masked_contrast&#x2F;#!d4enrn&quot;&gt;here&lt;&#x2F;a&gt;. It’s a self-contained single-file applet with no build pipeline, so View Source will show all the sausages being made should you feel so inclined. The various “Hello, world!” example images above and below link to this demo prepopulated with the parameters used to create them; you can tweak parameters to compare my (necessarily subjective) perceptual judgements with your own, or run your browser’s accessibility checker against them in the DOM draw method mode to see what they make of it.&lt;&#x2F;p&gt;
&lt;p&gt;Caveat: the image-based analysis in Canvas draw mode won’t work in current Safari because it doesn’t support &lt;code&gt;filter&lt;&#x2F;code&gt;, and I haven’t tested on mobile. The overlays (e.g. outline mask or heatmap) shown in some images aren’t part of persistent page state and so can’t be set by the links; they’re triggered by holding down one of the labelled buttons.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;lighthouse-and-the-analytic-approach&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#lighthouse-and-the-analytic-approach&quot; aria-label=&quot;Anchor link for: lighthouse-and-the-analytic-approach&quot;&gt;Lighthouse and the analytic approach&lt;&#x2F;a&gt;&lt;&#x2F;h2&gt;
&lt;p&gt;When I first noticed that Lighthouse didn’t object to my header, I decided that it was a splendid tool. When I subsequently found that Lighthouse just gives up on assessing any element with a &lt;code&gt;background-image&lt;&#x2F;code&gt;, I decided that it was a terrible tool. When I found out even later that without a &lt;code&gt;background-image&lt;&#x2F;code&gt; Lighthouse goes to considerable lengths to account for &lt;code&gt;text-shadow&lt;&#x2F;code&gt;, I decided that maybe I have an unhealthy habit of jumping to conclusions.&lt;&#x2F;p&gt;
&lt;p&gt;Lighthouse considers the presence of a shadow, its colour, blur radius and offset. I don’t necessarily agree with all its choices, but it’s a serious effort. If you want to dig into the implementation, most of it is in &lt;a class=&quot;external&quot; rel=&quot;nofollow noreferrer&quot; href=&quot;https:&#x2F;&#x2F;github.com&#x2F;dequelabs&#x2F;axe-core&#x2F;blob&#x2F;develop&#x2F;lib&#x2F;commons&#x2F;color&#x2F;get-text-shadow-colors.js&quot;&gt;&lt;code&gt;axe-core&lt;&#x2F;code&gt;’s get-text-shadow-colors.js&lt;&#x2F;a&gt; and &lt;a class=&quot;external&quot; rel=&quot;nofollow noreferrer&quot; href=&quot;https:&#x2F;&#x2F;github.com&#x2F;dequelabs&#x2F;axe-core&#x2F;blob&#x2F;develop&#x2F;lib&#x2F;commons&#x2F;color&#x2F;get-stroke-colors-from-shadows.js&quot;&gt;get-stroke-colors-from-shadows.js&lt;&#x2F;a&gt; under the MPL 2.0 license. My main reservation is that its internals lean too heavily on binary thresholds rather than continuous functions. I’m not (just) talking about the binary pass&#x2F;fail exposed through Lighthouse, it’s full of internal rules like “if offset is more than blur radius then ignore the shadow, but if it’s even a smidge under then it’s fine”. I’ve noticed several cases where I think Lighthouse passes things it shouldn’t, e.g. &lt;a class=&quot;external&quot; rel=&quot;nofollow noreferrer&quot; href=&quot;https:&#x2F;&#x2F;mrec.github.io&#x2F;webtoys&#x2F;masked_contrast&#x2F;#!d1entn&quot;&gt;weak narrow blurs&lt;&#x2F;a&gt;, but it’s not really fair to pick on those too much. I very much doubt that any solution will be free of warts. At least some of my decision to try reinventing the wheel here was just that it’s an interesting problem; as such, given that Lighthouse’s existence has already demonstrated that an analytic approach is at least somewhat feasible, you’re obviously free to skip ahead to the next section.&lt;&#x2F;p&gt;
&lt;details&gt;
&lt;summary&gt;A peculiar observation when foreground and background are the same&lt;&#x2F;summary&gt;
&lt;p&gt;For some reason, when foreground and background colours are exactly the same, Lighthouse reports that accessibility is absolutely fine. This is regardless of any shadow. At first I thought it was hitting some sort of divide-by-zero internally and falling over, but it might also be a deliberate rule to handle an old webdev pattern which used this trick to hide content from most users while still showing it to screen readers.&lt;&#x2F;p&gt;
&lt;p&gt;Either way, it’s a little disconcerting. It’s the sort of mistake that could genuinely happen if you were converting a light-mode stylesheet to dark mode and missed something. It can also give you misleading ideas about Lighthouse’s analysis; the white foreground&#x2F;background, black shadow combination was an obvious experiment to try when testing its shadow handling.&lt;&#x2F;p&gt;
&lt;&#x2F;details&gt;
&lt;p&gt;I was curious to see where starting from first principles would get me, and eventually boiled the perceptual considerations listed earlier down into two main factors: &lt;strong&gt;exposure&lt;&#x2F;strong&gt; and &lt;strong&gt;dilution&lt;&#x2F;strong&gt;.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;Exposure&lt;&#x2F;strong&gt; estimates how much of a shadow ends up somewhere useful; neither hidden under a glyph nor too far away from it to be effective. Exposure can be increased up to a point by either offset (moving the shadow out from under), blur (spreading the shadow out from under) or a combination of the two. In both cases the sweet spot is largely driven by the font’s stem width, the thickness of each line making up a glyph. This isn’t something that font metrics expose, so I’m estimating it to be roughly a tenth of the font size; the real number will vary by resolved &lt;code&gt;font-family&lt;&#x2F;code&gt; and in a serious implementation should be adjusted for &lt;code&gt;font-weight&lt;&#x2F;code&gt;. From experimentation, going over the sweet spot hurts legibility more than being under it, so exposure calculations use an opinionated helper function that applies exponential penalties over the ideal level:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;js&quot; style=&quot;background-color:#ffffff;color:#000000;&quot; class=&quot;language-js &quot;&gt;&lt;code class=&quot;language-js&quot; data-lang=&quot;js&quot;&gt;&lt;span style=&quot;color:#aa2063;&quot;&gt;function &lt;&#x2F;span&gt;&lt;span style=&quot;color:#7f56c7;&quot;&gt;opinionatedExposure&lt;&#x2F;span&gt;&lt;span&gt;(stemWidth, raw, ideal, excessExponent) {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#aa2063;&quot;&gt;let &lt;&#x2F;span&gt;&lt;span&gt;norm &lt;&#x2F;span&gt;&lt;span style=&quot;color:#0000ff;&quot;&gt;= &lt;&#x2F;span&gt;&lt;span&gt;raw &lt;&#x2F;span&gt;&lt;span style=&quot;color:#0000ff;&quot;&gt;&#x2F; &lt;&#x2F;span&gt;&lt;span&gt;stemWidth;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#aa2063;&quot;&gt;let &lt;&#x2F;span&gt;&lt;span&gt;exposure &lt;&#x2F;span&gt;&lt;span style=&quot;color:#0000ff;&quot;&gt;= &lt;&#x2F;span&gt;&lt;span&gt;norm &lt;&#x2F;span&gt;&lt;span style=&quot;color:#0000ff;&quot;&gt;&#x2F; &lt;&#x2F;span&gt;&lt;span&gt;ideal;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#9062a1;&quot;&gt;if &lt;&#x2F;span&gt;&lt;span&gt;(exposure &lt;&#x2F;span&gt;&lt;span style=&quot;color:#0000ff;&quot;&gt;&amp;gt; &lt;&#x2F;span&gt;&lt;span&gt;1) exposure &lt;&#x2F;span&gt;&lt;span style=&quot;color:#0000ff;&quot;&gt;&#x2F;= &lt;&#x2F;span&gt;&lt;span&gt;(exposure &lt;&#x2F;span&gt;&lt;span style=&quot;color:#0000ff;&quot;&gt;** &lt;&#x2F;span&gt;&lt;span&gt;excessExponent);
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#9062a1;&quot;&gt;return &lt;&#x2F;span&gt;&lt;span&gt;exposure;
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;&lt;strong&gt;Dilution&lt;&#x2F;strong&gt; estimates how much a shadow’s opacity is reduced by blur. This turned out to be a nasty, nasty problem. A simple closed-form equation based on radius penalizes large blurs too much; perceptually, we’re mostly interested in the peak opacity at a glyph edge. Lower opacity further out might not help, but it doesn’t actively hurt. A weighted 1D Gaussian approximation dramatically underestimates opacity, because the shadow blur we’re doing is 2D, meaning far more input pixels contribute to the output, in glyph-area-dependent ways. Looking at 2D Gaussians led me to things like Abramowitz and Stegun’s fast erf approximation, which is so far outside my mathematically-challenged comfort zone that I couldn’t see my mathematically-challenged sofa with a telescope.&lt;&#x2F;p&gt;
&lt;p&gt;At this point I stepped back, took some empirical measurements of edge shadow opacity at various blurs, and fitted them to a curve; we’re never going to do better than an approximation here, and ultimately pragmatism won out. (Lighthouse does the same kind of thing, which makes me feel a bit better.)&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;js&quot; style=&quot;background-color:#ffffff;color:#000000;&quot; class=&quot;language-js &quot;&gt;&lt;code class=&quot;language-js&quot; data-lang=&quot;js&quot;&gt;&lt;span style=&quot;color:#aa2063;&quot;&gt;function &lt;&#x2F;span&gt;&lt;span style=&quot;color:#7f56c7;&quot;&gt;fittedAlpha&lt;&#x2F;span&gt;&lt;span&gt;(blur) {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#9062a1;&quot;&gt;return &lt;&#x2F;span&gt;&lt;span&gt;1 &lt;&#x2F;span&gt;&lt;span style=&quot;color:#0000ff;&quot;&gt;&#x2F; &lt;&#x2F;span&gt;&lt;span&gt;(1 &lt;&#x2F;span&gt;&lt;span style=&quot;color:#0000ff;&quot;&gt;+ &lt;&#x2F;span&gt;&lt;span&gt;9.035 &lt;&#x2F;span&gt;&lt;span style=&quot;color:#0000ff;&quot;&gt;* &lt;&#x2F;span&gt;&lt;span&gt;(blur &lt;&#x2F;span&gt;&lt;span style=&quot;color:#0000ff;&quot;&gt;&#x2F; &lt;&#x2F;span&gt;&lt;span&gt;fontSize) &lt;&#x2F;span&gt;&lt;span style=&quot;color:#0000ff;&quot;&gt;** &lt;&#x2F;span&gt;&lt;span&gt;2);
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;With both exposure and dilution in hand, we can start to put everything together:&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;Estimate exposure contributions from offset and blur using the opinionated helper shown earlier, blend them in a way that reflects blur’s greater perceptual impact and adds a small nod to the observation that a combination of blur and offset can be more than the sum of its parts.&lt;&#x2F;li&gt;
&lt;li&gt;Estimate the luminance of the shadow based on dilution and stacking, and calculate how much contrast that shadow could ideally provide.&lt;&#x2F;li&gt;
&lt;li&gt;Use our combined exposure to weight the relative impacts of ideal text&#x2F;shadow and text&#x2F;background contrasts.&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;This is cut down from the &lt;a class=&quot;external&quot; rel=&quot;nofollow noreferrer&quot; href=&quot;https:&#x2F;&#x2F;github.com&#x2F;mrec&#x2F;webtoys&#x2F;blob&#x2F;main&#x2F;masked_contrast&#x2F;index.html#L267&quot;&gt;webtoy source&lt;&#x2F;a&gt;; if you want to dig into the details, the original has extensive comments for each line.&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;js&quot; style=&quot;background-color:#ffffff;color:#000000;&quot; class=&quot;language-js &quot;&gt;&lt;code class=&quot;language-js&quot; data-lang=&quot;js&quot;&gt;&lt;span style=&quot;font-style:italic;color:#3c802c;&quot;&gt;&#x2F;&#x2F; bgLum, fgLum, shadowLum are luminance values in the range 0..=1
&lt;&#x2F;span&gt;&lt;span style=&quot;font-style:italic;color:#3c802c;&quot;&gt;&#x2F;&#x2F; stack is the number of shadow clones
&lt;&#x2F;span&gt;&lt;span style=&quot;font-style:italic;color:#3c802c;&quot;&gt;&#x2F;&#x2F; luminance and contrast functions follow the https:&#x2F;&#x2F;www.w3.org&#x2F;TR&#x2F;WCAG21&#x2F; formulae
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#aa2063;&quot;&gt;const &lt;&#x2F;span&gt;&lt;span&gt;baseContrast &lt;&#x2F;span&gt;&lt;span style=&quot;color:#0000ff;&quot;&gt;= &lt;&#x2F;span&gt;&lt;span style=&quot;color:#7f56c7;&quot;&gt;contrast&lt;&#x2F;span&gt;&lt;span&gt;(bgLum, fgLum);
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#aa2063;&quot;&gt;const &lt;&#x2F;span&gt;&lt;span&gt;offset &lt;&#x2F;span&gt;&lt;span style=&quot;color:#0000ff;&quot;&gt;= Math.max&lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#0000ff;&quot;&gt;Math.abs&lt;&#x2F;span&gt;&lt;span&gt;(x), &lt;&#x2F;span&gt;&lt;span style=&quot;color:#0000ff;&quot;&gt;Math.abs&lt;&#x2F;span&gt;&lt;span&gt;(y));
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#aa2063;&quot;&gt;const &lt;&#x2F;span&gt;&lt;span&gt;offsetExposure &lt;&#x2F;span&gt;&lt;span style=&quot;color:#0000ff;&quot;&gt;= &lt;&#x2F;span&gt;&lt;span style=&quot;color:#7f56c7;&quot;&gt;opinionatedExposure&lt;&#x2F;span&gt;&lt;span&gt;(stemWidth, offset, 0.6, 4);
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#aa2063;&quot;&gt;const &lt;&#x2F;span&gt;&lt;span&gt;blurExposure &lt;&#x2F;span&gt;&lt;span style=&quot;color:#0000ff;&quot;&gt;= &lt;&#x2F;span&gt;&lt;span style=&quot;color:#7f56c7;&quot;&gt;opinionatedExposure&lt;&#x2F;span&gt;&lt;span&gt;(stemWidth, blur, 1.4, 1.5);
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#aa2063;&quot;&gt;const &lt;&#x2F;span&gt;&lt;span&gt;combinedExposure 
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#0000ff;&quot;&gt;= &lt;&#x2F;span&gt;&lt;span&gt;(0.2 &lt;&#x2F;span&gt;&lt;span style=&quot;color:#0000ff;&quot;&gt;* &lt;&#x2F;span&gt;&lt;span&gt;offsetExposure) 
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#0000ff;&quot;&gt;+ &lt;&#x2F;span&gt;&lt;span&gt;(0.7 &lt;&#x2F;span&gt;&lt;span style=&quot;color:#0000ff;&quot;&gt;* &lt;&#x2F;span&gt;&lt;span&gt;blurExposure) 
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#0000ff;&quot;&gt;+ &lt;&#x2F;span&gt;&lt;span&gt;(0.1 &lt;&#x2F;span&gt;&lt;span style=&quot;color:#0000ff;&quot;&gt;* &lt;&#x2F;span&gt;&lt;span&gt;offsetExposure &lt;&#x2F;span&gt;&lt;span style=&quot;color:#0000ff;&quot;&gt;* &lt;&#x2F;span&gt;&lt;span&gt;blurExposure);
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#aa2063;&quot;&gt;const &lt;&#x2F;span&gt;&lt;span&gt;dilutedAlpha &lt;&#x2F;span&gt;&lt;span style=&quot;color:#0000ff;&quot;&gt;= &lt;&#x2F;span&gt;&lt;span style=&quot;color:#7f56c7;&quot;&gt;fittedAlpha&lt;&#x2F;span&gt;&lt;span&gt;(blur);
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#aa2063;&quot;&gt;const &lt;&#x2F;span&gt;&lt;span&gt;bgShineThrough &lt;&#x2F;span&gt;&lt;span style=&quot;color:#0000ff;&quot;&gt;= &lt;&#x2F;span&gt;&lt;span&gt;(1 &lt;&#x2F;span&gt;&lt;span style=&quot;color:#0000ff;&quot;&gt;- &lt;&#x2F;span&gt;&lt;span&gt;dilutedAlpha) &lt;&#x2F;span&gt;&lt;span style=&quot;color:#0000ff;&quot;&gt;** &lt;&#x2F;span&gt;&lt;span&gt;stack;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#aa2063;&quot;&gt;const &lt;&#x2F;span&gt;&lt;span&gt;shadowedBgLum &lt;&#x2F;span&gt;&lt;span style=&quot;color:#0000ff;&quot;&gt;= &lt;&#x2F;span&gt;&lt;span&gt;shadowLum &lt;&#x2F;span&gt;&lt;span style=&quot;color:#0000ff;&quot;&gt;* &lt;&#x2F;span&gt;&lt;span&gt;(1 &lt;&#x2F;span&gt;&lt;span style=&quot;color:#0000ff;&quot;&gt;- &lt;&#x2F;span&gt;&lt;span&gt;bgShineThrough) &lt;&#x2F;span&gt;&lt;span style=&quot;color:#0000ff;&quot;&gt;+ &lt;&#x2F;span&gt;&lt;span&gt;bgLum &lt;&#x2F;span&gt;&lt;span style=&quot;color:#0000ff;&quot;&gt;* &lt;&#x2F;span&gt;&lt;span&gt;bgShineThrough;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#aa2063;&quot;&gt;const &lt;&#x2F;span&gt;&lt;span&gt;idealContrast &lt;&#x2F;span&gt;&lt;span style=&quot;color:#0000ff;&quot;&gt;= &lt;&#x2F;span&gt;&lt;span style=&quot;color:#7f56c7;&quot;&gt;contrast&lt;&#x2F;span&gt;&lt;span&gt;(fgLum, shadowedBgLum);
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#aa2063;&quot;&gt;const &lt;&#x2F;span&gt;&lt;span&gt;finalContrast &lt;&#x2F;span&gt;&lt;span style=&quot;color:#0000ff;&quot;&gt;= &lt;&#x2F;span&gt;&lt;span&gt;idealContrast &lt;&#x2F;span&gt;&lt;span style=&quot;color:#0000ff;&quot;&gt;* &lt;&#x2F;span&gt;&lt;span&gt;combinedExposure &lt;&#x2F;span&gt;&lt;span style=&quot;color:#0000ff;&quot;&gt;+ &lt;&#x2F;span&gt;&lt;span&gt;baseContrast &lt;&#x2F;span&gt;&lt;span style=&quot;color:#0000ff;&quot;&gt;* &lt;&#x2F;span&gt;&lt;span&gt;(1 &lt;&#x2F;span&gt;&lt;span style=&quot;color:#0000ff;&quot;&gt;- &lt;&#x2F;span&gt;&lt;span&gt;combinedExposure);
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;From that code we get an analytic report with concrete numbers like &lt;a class=&quot;external&quot; rel=&quot;nofollow noreferrer&quot; href=&quot;https:&#x2F;&#x2F;mrec.github.io&#x2F;webtoys&#x2F;masked_contrast&#x2F;#!d2etr&quot;&gt;this&lt;&#x2F;a&gt;:&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#ffffff;color:#000000;&quot;&gt;&lt;code&gt;&lt;span&gt;background colour: rgb(221, 238, 255)
&lt;&#x2F;span&gt;&lt;span&gt;  luminance: 0.84
&lt;&#x2F;span&gt;&lt;span&gt;text colour: rgb(238, 238, 238)
&lt;&#x2F;span&gt;&lt;span&gt;  luminance: 0.85
&lt;&#x2F;span&gt;&lt;span&gt;text&#x2F;background contrast: 1.02
&lt;&#x2F;span&gt;&lt;span&gt;shadow: rgb(0, 0, 0) 2px 2px 7px
&lt;&#x2F;span&gt;&lt;span&gt;  stack: x2
&lt;&#x2F;span&gt;&lt;span&gt;  base luminance: 0.00
&lt;&#x2F;span&gt;&lt;span&gt;  exposure:
&lt;&#x2F;span&gt;&lt;span&gt;    offset: 0.69
&lt;&#x2F;span&gt;&lt;span&gt;    blur: 0.98
&lt;&#x2F;span&gt;&lt;span&gt;    combined: 0.89
&lt;&#x2F;span&gt;&lt;span&gt;  dilutedAlpha (per shadow): 0.84
&lt;&#x2F;span&gt;&lt;span&gt;  dilutedAlpha (cumulative): 0.97
&lt;&#x2F;span&gt;&lt;span&gt;  shadowed background luminance: 0.02
&lt;&#x2F;span&gt;&lt;span&gt;  ideal shadow contrast: 12.61
&lt;&#x2F;span&gt;&lt;span&gt;final exposure-adjusted contrast: 11.37
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;So: is this approach viable? Up to a point, yes. It’s obviously extremely opinionated, and I don’t claim for a moment that any particular formula or tuning constant is the best one. But the exposure&#x2F;dilution framing seemed to help keep things manageable, and the output numbers do generally move in the right direction when twiddling shadow settings. For simple shadows and simple backgrounds it’s fine.&lt;&#x2F;p&gt;
&lt;p&gt;However, it’s an incomplete tool. It would need extension and testing for different fonts, sizes, weights, and multiple shadows that aren’t just clones of each other. It doesn’t (and can’t) take complex backgrounds into account, and this isn’t some weird edge case: one of the prime uses of &lt;code&gt;text-shadow&lt;&#x2F;code&gt; is to ensure contrast against arbitrary backgrounds. It would be utterly unfair to expect it to understand and predict the effect of something like an arbitrary &lt;a class=&quot;external&quot; rel=&quot;nofollow noreferrer&quot; href=&quot;https:&#x2F;&#x2F;developer.mozilla.org&#x2F;en-US&#x2F;docs&#x2F;Web&#x2F;SVG&#x2F;Reference&#x2F;Element&#x2F;filter&quot;&gt;SVG filter&lt;&#x2F;a&gt; applied via a &lt;a class=&quot;external&quot; rel=&quot;nofollow noreferrer&quot; href=&quot;https:&#x2F;&#x2F;developer.mozilla.org&#x2F;en-US&#x2F;docs&#x2F;Web&#x2F;CSS&#x2F;filter&quot;&gt;CSS filter&lt;&#x2F;a&gt;, a much more powerful and flexible tool for effects like this. For a more robust and general solution, we’d need to turn to image-based approaches.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;firefox-and-the-image-based-approach&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#firefox-and-the-image-based-approach&quot; aria-label=&quot;Anchor link for: firefox-and-the-image-based-approach&quot;&gt;Firefox and the image-based approach&lt;&#x2F;a&gt;&lt;&#x2F;h2&gt;
&lt;p&gt;Unlike Lighthouse, Firefox’s accessibility checker does cope with text over a background image. It hides the text, renders the layout box the text would fill, grabs the background pixels in that box, finds the lightest and darkest of those pixels and assesses contrast with whichever of those is worse for the text colour. This is ambitious, flexible and praiseworthy. Unfortunately it doesn’t work for &lt;code&gt;text-shadow&lt;&#x2F;code&gt;. To fix that, three hurdles would need to be cleared.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;First hurdle:&lt;&#x2F;strong&gt; Firefox doesn’t &lt;em&gt;see&lt;&#x2F;em&gt; the shadow. It hides the text by (I think) temporarily setting &lt;code&gt;visibility: hidden&lt;&#x2F;code&gt; on it, making it invisible without disturbing layout. However, when you do this, the text shadow doesn’t get drawn either, and we really wanted that to be part of the background capture.&lt;&#x2F;p&gt;
&lt;p&gt;This one looks relatively easy to resolve. If instead of &lt;code&gt;visibility: hidden&lt;&#x2F;code&gt; we give the text a colour with an alpha component of zero, it’ll still be invisible, but the shadow does get drawn since it’s drawn using the shadow colour, not the text colour. You can confirm this via the DOM inspector.&lt;&#x2F;p&gt;
&lt;details&gt;
&lt;summary&gt;What about shadows with no background image?&lt;&#x2F;summary&gt;
&lt;p&gt;I’d have thought that in this case Firefox would fall back to an analytic approach, especially since coming across various references to it using at least parts of &lt;code&gt;axe-core&lt;&#x2F;code&gt;, the accessibility engine behind Lighthouse. But either it doesn’t, or that analysis doesn’t look at &lt;code&gt;text-shadow&lt;&#x2F;code&gt; either. With white foreground&#x2F;background, black shadow and no &lt;code&gt;background-image&lt;&#x2F;code&gt;, Firefox only reports a white background.&lt;&#x2F;p&gt;
&lt;&#x2F;details&gt;
&lt;p&gt;&lt;strong&gt;Second hurdle:&lt;&#x2F;strong&gt; background pixel sampling looks at too many pixels. This cuts both ways. Most obviously, it looks at pixels in the text’s layout box but not covered by a shadow hugging the glyph edges; this would make it unduly pessimistic about contrast. Less obviously, it looks at shadow pixels which are nice and opaque but are also entirely hidden by the glyph; this could make it unduly optimistic about contrast.&lt;&#x2F;p&gt;
&lt;p&gt;If what matters for legibility is the fairly narrow band of pixels around each glyph, it would be nice to only consider those. We want an outline mask, and happily we can build one using an SVG dilation filter. Take the text’s alpha channel, threshold it to 0&#x2F;1 to avoid nasty fringe effects from antialiasing, dilate it to grow outwards by our desired outline mask thickness, knock out the original text mask, and paint it something distinctive for displaying as a debug overlay. Render text to a canvas using our filter, grab the pixels and convert it to an alpha mask.&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;xml&quot; style=&quot;background-color:#ffffff;color:#000000;&quot; class=&quot;language-xml &quot;&gt;&lt;code class=&quot;language-xml&quot; data-lang=&quot;xml&quot;&gt;&lt;span&gt;&amp;lt;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#291fb7;&quot;&gt;filter &lt;&#x2F;span&gt;&lt;span style=&quot;color:#881181;&quot;&gt;id&lt;&#x2F;span&gt;&lt;span&gt;=&lt;&#x2F;span&gt;&lt;span style=&quot;color:#00737d;&quot;&gt;&amp;quot;dilate&amp;quot; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#881181;&quot;&gt;x&lt;&#x2F;span&gt;&lt;span&gt;=&lt;&#x2F;span&gt;&lt;span style=&quot;color:#00737d;&quot;&gt;&amp;quot;-10%&amp;quot; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#881181;&quot;&gt;y&lt;&#x2F;span&gt;&lt;span&gt;=&lt;&#x2F;span&gt;&lt;span style=&quot;color:#00737d;&quot;&gt;&amp;quot;-10%&amp;quot; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#881181;&quot;&gt;width&lt;&#x2F;span&gt;&lt;span&gt;=&lt;&#x2F;span&gt;&lt;span style=&quot;color:#00737d;&quot;&gt;&amp;quot;120%&amp;quot; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#881181;&quot;&gt;height&lt;&#x2F;span&gt;&lt;span&gt;=&lt;&#x2F;span&gt;&lt;span style=&quot;color:#00737d;&quot;&gt;&amp;quot;120%&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;&amp;gt;
&lt;&#x2F;span&gt;&lt;span&gt;    &amp;lt;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#291fb7;&quot;&gt;feComponentTransfer &lt;&#x2F;span&gt;&lt;span style=&quot;color:#881181;&quot;&gt;in&lt;&#x2F;span&gt;&lt;span&gt;=&lt;&#x2F;span&gt;&lt;span style=&quot;color:#00737d;&quot;&gt;&amp;quot;SourceAlpha&amp;quot; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#881181;&quot;&gt;result&lt;&#x2F;span&gt;&lt;span&gt;=&lt;&#x2F;span&gt;&lt;span style=&quot;color:#00737d;&quot;&gt;&amp;quot;alpha&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;&amp;gt;
&lt;&#x2F;span&gt;&lt;span&gt;        &amp;lt;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#291fb7;&quot;&gt;feFuncA &lt;&#x2F;span&gt;&lt;span style=&quot;color:#881181;&quot;&gt;type&lt;&#x2F;span&gt;&lt;span&gt;=&lt;&#x2F;span&gt;&lt;span style=&quot;color:#00737d;&quot;&gt;&amp;quot;discrete&amp;quot; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#881181;&quot;&gt;tableValues&lt;&#x2F;span&gt;&lt;span&gt;=&lt;&#x2F;span&gt;&lt;span style=&quot;color:#00737d;&quot;&gt;&amp;quot;0 1&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;&#x2F;&amp;gt;
&lt;&#x2F;span&gt;&lt;span&gt;    &amp;lt;&#x2F;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#291fb7;&quot;&gt;feComponentTransfer&lt;&#x2F;span&gt;&lt;span&gt;&amp;gt;
&lt;&#x2F;span&gt;&lt;span&gt;    &amp;lt;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#291fb7;&quot;&gt;feMorphology &lt;&#x2F;span&gt;&lt;span style=&quot;color:#881181;&quot;&gt;in&lt;&#x2F;span&gt;&lt;span&gt;=&lt;&#x2F;span&gt;&lt;span style=&quot;color:#00737d;&quot;&gt;&amp;quot;alpha&amp;quot; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#881181;&quot;&gt;operator&lt;&#x2F;span&gt;&lt;span&gt;=&lt;&#x2F;span&gt;&lt;span style=&quot;color:#00737d;&quot;&gt;&amp;quot;dilate&amp;quot; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#881181;&quot;&gt;radius&lt;&#x2F;span&gt;&lt;span&gt;=&lt;&#x2F;span&gt;&lt;span style=&quot;color:#00737d;&quot;&gt;&amp;quot;${maskWidth}&amp;quot; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#881181;&quot;&gt;result&lt;&#x2F;span&gt;&lt;span&gt;=&lt;&#x2F;span&gt;&lt;span style=&quot;color:#00737d;&quot;&gt;&amp;quot;dilated&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;&#x2F;&amp;gt;
&lt;&#x2F;span&gt;&lt;span&gt;    &amp;lt;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#291fb7;&quot;&gt;feComposite &lt;&#x2F;span&gt;&lt;span style=&quot;color:#881181;&quot;&gt;in&lt;&#x2F;span&gt;&lt;span&gt;=&lt;&#x2F;span&gt;&lt;span style=&quot;color:#00737d;&quot;&gt;&amp;quot;dilated&amp;quot; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#881181;&quot;&gt;in2&lt;&#x2F;span&gt;&lt;span&gt;=&lt;&#x2F;span&gt;&lt;span style=&quot;color:#00737d;&quot;&gt;&amp;quot;alpha&amp;quot; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#881181;&quot;&gt;operator&lt;&#x2F;span&gt;&lt;span&gt;=&lt;&#x2F;span&gt;&lt;span style=&quot;color:#00737d;&quot;&gt;&amp;quot;out&amp;quot; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#881181;&quot;&gt;result&lt;&#x2F;span&gt;&lt;span&gt;=&lt;&#x2F;span&gt;&lt;span style=&quot;color:#00737d;&quot;&gt;&amp;quot;border&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;&#x2F;&amp;gt;
&lt;&#x2F;span&gt;&lt;span&gt;    &amp;lt;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#291fb7;&quot;&gt;feFlood &lt;&#x2F;span&gt;&lt;span style=&quot;color:#881181;&quot;&gt;flood-color&lt;&#x2F;span&gt;&lt;span&gt;=&lt;&#x2F;span&gt;&lt;span style=&quot;color:#00737d;&quot;&gt;&amp;quot;fuchsia&amp;quot; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#881181;&quot;&gt;result&lt;&#x2F;span&gt;&lt;span&gt;=&lt;&#x2F;span&gt;&lt;span style=&quot;color:#00737d;&quot;&gt;&amp;quot;flood&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;&#x2F;&amp;gt;
&lt;&#x2F;span&gt;&lt;span&gt;    &amp;lt;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#291fb7;&quot;&gt;feComposite &lt;&#x2F;span&gt;&lt;span style=&quot;color:#881181;&quot;&gt;in&lt;&#x2F;span&gt;&lt;span&gt;=&lt;&#x2F;span&gt;&lt;span style=&quot;color:#00737d;&quot;&gt;&amp;quot;flood&amp;quot; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#881181;&quot;&gt;in2&lt;&#x2F;span&gt;&lt;span&gt;=&lt;&#x2F;span&gt;&lt;span style=&quot;color:#00737d;&quot;&gt;&amp;quot;border&amp;quot; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#881181;&quot;&gt;operator&lt;&#x2F;span&gt;&lt;span&gt;=&lt;&#x2F;span&gt;&lt;span style=&quot;color:#00737d;&quot;&gt;&amp;quot;in&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;&#x2F;&amp;gt;
&lt;&#x2F;span&gt;&lt;span&gt;&amp;lt;&#x2F;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#291fb7;&quot;&gt;filter&lt;&#x2F;span&gt;&lt;span&gt;&amp;gt;
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;details&gt;
&lt;summary&gt;Wouldn’t an edge detection filter make more sense?&lt;&#x2F;summary&gt;
&lt;p&gt;Since we’re looking for well-defined edges, it feels as if something like a &lt;a class=&quot;external&quot; rel=&quot;nofollow noreferrer&quot; href=&quot;https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Sobel_operator&quot;&gt;Sobel filter&lt;&#x2F;a&gt; ought to be useful. This is eminently doable in SVG, but in practice doesn’t really offer anything over the dilate-mask approach. After all, we already know where the edges are, so finding them again from first principles is a bit redundant.&lt;&#x2F;p&gt;
&lt;p&gt;One situation where edge detection might be useful is when considering &lt;a class=&quot;external&quot; rel=&quot;nofollow noreferrer&quot; href=&quot;https:&#x2F;&#x2F;mrec.github.io&#x2F;webtoys&#x2F;masked_contrast&#x2F;#!d4vnrn&quot;&gt;blurry text&lt;&#x2F;a&gt;, either from an explicit CSS &lt;code&gt;filter: blur&lt;&#x2F;code&gt; or from a blurred shadow colour matching the text colour. Rather than generating the outline mask outside the glyph edge, we might centre it over the edge and look for strong Sobel pixels within that mask. This is a bit of a digression, though, and would have its own issues. It wouldn’t be any more forgiving of one-sided contrast from an offset shadow than the dilation approach, and it would be vulnerable to false edges from a noisy background (e.g. vertical pinstripes) that happened to coincide with glyph edges.&lt;&#x2F;p&gt;
&lt;p&gt;There’s still something very tempting here. It’s the only technique I can think of which sidesteps the arbitary foreground&#x2F;background dichotomy mentioned in an earlier subyak.&lt;&#x2F;p&gt;
&lt;&#x2F;details&gt;
&lt;p&gt;Now when we scan our background pixels, we can check whether the corresponding pixel in the mask is set, and skip pixels that aren’t covered. The difference in coverage between “all pixels in the layout box” and “only pixels covered by the outline mask” (2px wide in this example) is dramatic.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;a class=&quot;external&quot; rel=&quot;nofollow noreferrer&quot; href=&quot;https:&#x2F;&#x2F;mrec.github.io&#x2F;webtoys&#x2F;masked_contrast&#x2F;#!c2vtr&quot;&gt;&lt;img src=&quot;https:&#x2F;&#x2F;mrec.github.io&#x2F;blog&#x2F;2025&#x2F;text-shadow&#x2F;overlay_box.webp&quot; alt=&quot;layout box debug overlay&quot; &#x2F;&gt;&lt;&#x2F;a&gt;
&lt;a class=&quot;external&quot; rel=&quot;nofollow noreferrer&quot; href=&quot;https:&#x2F;&#x2F;mrec.github.io&#x2F;webtoys&#x2F;masked_contrast&#x2F;#!c2vtr&quot;&gt;&lt;img src=&quot;https:&#x2F;&#x2F;mrec.github.io&#x2F;blog&#x2F;2025&#x2F;text-shadow&#x2F;overlay_mask.webp&quot; alt=&quot;outline mask debug overlay&quot; &#x2F;&gt;&lt;&#x2F;a&gt;&lt;&#x2F;p&gt;
&lt;details&gt;
&lt;summary&gt;Why implementing this for the PoC was mildly unfun&lt;&#x2F;summary&gt;
&lt;p&gt;Page script isn’t allowed to render DOM content into a &lt;code&gt;&amp;lt;canvas&amp;gt;&lt;&#x2F;code&gt;; this is for solid privacy reasons, like not exposing which links you’ve visited by their colour. Robert O’Callahan laid out a &lt;a class=&quot;external&quot; rel=&quot;nofollow noreferrer&quot; href=&quot;https:&#x2F;&#x2F;robert.ocallahan.org&#x2F;2011&#x2F;11&#x2F;drawing-dom-content-to-canvas.html&quot;&gt;technique&lt;&#x2F;a&gt; around 15 years ago to accomplish this using SVG’s &lt;code&gt;&amp;lt;foreignObject&amp;gt;&lt;&#x2F;code&gt;, but I think that loophole has since been closed; the corresponding MDN documentation is gone. A couple of current libraries claim to do something similar, but it all feels very fragile; I get the distinct sense that there are more shoes waiting to drop here.&lt;&#x2F;p&gt;
&lt;p&gt;Canvas is the only (web platform) mechanism we have to read back rendered pixels for contrast checking. So for the image-based approach the PoC has to replicate DOM rendering using pure canvas as best it can. This threw up a number of issues, notably with vertical text alignment and with blur radius parameters, which are treated subtly differently by the CSS and canvas rendering models.&lt;&#x2F;p&gt;
&lt;p&gt;As I understand it, the accessibility checker in Firefox wouldn’t have these restrictions; it’s running script in a privileged browser-chrome context which is assumed to be trustworthy.&lt;&#x2F;p&gt;
&lt;&#x2F;details&gt;
&lt;p&gt;&lt;strong&gt;Third hurdle:&lt;&#x2F;strong&gt; assessment based on the worst-contrasting pixel is too strict. Even with the mask restriction and a visually perfectly acceptable shadow setup, metrics show “only” a 97% pass rate against the 3:1 contrast criterion, and 89% against the 4.5:1 one. Adding a heatmap overlay shows the problem is exactly where expected, at the outer extremities of stems. It’s predictably worse for offset shadows despite the perceptual benefits of stronger contrast on one edge, and I’d expect it to be worse for serif fonts, since they have lots of small spiky protrusions that affect the outline mask but won’t generate much in the way of shadow opacity.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;a class=&quot;external&quot; rel=&quot;nofollow noreferrer&quot; href=&quot;https:&#x2F;&#x2F;mrec.github.io&#x2F;webtoys&#x2F;masked_contrast&#x2F;#!c4enr&quot;&gt;&lt;img src=&quot;https:&#x2F;&#x2F;mrec.github.io&#x2F;blog&#x2F;2025&#x2F;text-shadow&#x2F;heatmap_nearly.webp&quot; alt=&quot;heatmap for a decent shadow&quot; &#x2F;&gt;&lt;&#x2F;a&gt;&lt;&#x2F;p&gt;
&lt;p&gt;Narrowing the outline mask to single-pixel width gets us even closer (96.88% of pixels passing the 4.5:1 test, 99.94% the 3:1 test) but there’s still the odd pesky outlier.&lt;&#x2F;p&gt;
&lt;p&gt;One natural response might be to define the pass criterion in terms of mean contrast rather than worst-case, but this creates as many problems as it solves. One is that the WCAG21 criteria levels are very much toward the low end of the 1..=21 scale established by the contrast formula; with a naive mean, having even a quarter of background pixels with perfect contrast will more than compensate for the other three-quarters having none whatsoever. (The same issue causes our analytical approach to be too forgiving of &lt;a class=&quot;external&quot; rel=&quot;nofollow noreferrer&quot; href=&quot;https:&#x2F;&#x2F;mrec.github.io&#x2F;webtoys&#x2F;masked_contrast&#x2F;#!d4vxrn&quot;&gt;shadows that blur their text&lt;&#x2F;a&gt;. Lighthouse passes that one too.) Another is that, perceptually, the distribution of contrast matters very much. Both the following background patterns offer a 50&#x2F;50 mix of perfect and zero contrast, and hence similar mean contrasts, but one is very clearly worse than the other:&lt;&#x2F;p&gt;
&lt;p&gt;&lt;a class=&quot;external&quot; rel=&quot;nofollow noreferrer&quot; href=&quot;https:&#x2F;&#x2F;mrec.github.io&#x2F;webtoys&#x2F;masked_contrast&#x2F;#!c0xnnf&quot;&gt;&lt;img src=&quot;https:&#x2F;&#x2F;mrec.github.io&#x2F;blog&#x2F;2025&#x2F;text-shadow&#x2F;checker_fine.webp&quot; alt=&quot;unshadowed text on fine-grained checkerboard&quot; &#x2F;&gt;&lt;&#x2F;a&gt;
&lt;a class=&quot;external&quot; rel=&quot;nofollow noreferrer&quot; href=&quot;https:&#x2F;&#x2F;mrec.github.io&#x2F;webtoys&#x2F;masked_contrast&#x2F;#!c0xnnc&quot;&gt;&lt;img src=&quot;https:&#x2F;&#x2F;mrec.github.io&#x2F;blog&#x2F;2025&#x2F;text-shadow&#x2F;checker_coarse.webp&quot; alt=&quot;unshadowed text on coarse-grained checkerboard&quot; &#x2F;&gt;&lt;&#x2F;a&gt;&lt;&#x2F;p&gt;
&lt;details&gt;
&lt;summary&gt;Another peculiar observation&lt;&#x2F;summary&gt;
&lt;p&gt;Bizarrely, Firefox’s accessibiility checker is perfectly happy with either black or white text against either checkerboard pattern. It does complain about white-on-white with no background image, or about slightly off-white text on checkerboards, so I’ve no idea what’s going on there. Maybe it’s significant that this is a &lt;code&gt;data:&lt;&#x2F;code&gt; image URL rather than the usual kind?&lt;&#x2F;p&gt;
&lt;&#x2F;details&gt;
&lt;p&gt;Another idea might be to apply a low-pass filter to the background, in order to smooth out tiny gaps in contrast. This would help the very contrived checkerboard example, but I don’t think it would do much for our text shadows; it’d hurt the good areas more than it helped the bad ones. And more generally this is starting to feel suspiciously like special pleading, when the main appeal of the image-based approach was its generality.&lt;&#x2F;p&gt;
&lt;p&gt;If pressed I’d probably go for requiring a high (but not 100%) pixel pass rate and a lower but still meaningful bar for mean contrast on the rest, but ultimately the image-based approach is no more a silver bullet than the analytic one. I do still think the generality of this approach has more headroom for improvement and carries less risk of getting tangled in special-case rulesets, but I don’t think it’s ready to take over in its present form.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;por-que-no-los-dos&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#por-que-no-los-dos&quot; aria-label=&quot;Anchor link for: por-que-no-los-dos&quot;&gt;¿Por qué no los dos?&lt;&#x2F;a&gt;&lt;&#x2F;h2&gt;
&lt;p&gt;So why not both? The analytic approach can apply heuristics because it understands the rules driving rendering, but it lacks knowledge of backgrounds. The image-based approach can have perfect knowledge of backgrounds but is too general to allow meaningful heuristics. Instead of viewing these as competitors, they could usefully be combined.&lt;&#x2F;p&gt;
&lt;p&gt;Both Lighthouse and the PoC give up on analysis in the presence of a &lt;code&gt;background-image&lt;&#x2F;code&gt;, but there’s absolutely no reason why they have to. There’d still be substantial value in just assuming the worst possible background (either white or black, depending on whether the text colour is above or below the luminance midpoint) and plugging that assumption into the analytic formula. If the shadow can provide good enough contrast even in that worst case, we can still record a pass.&lt;&#x2F;p&gt;
&lt;p&gt;Firefox’s image-based approach could do better by supplying the &lt;em&gt;actual&lt;&#x2F;em&gt; worst-case pixel instead of an assumed one, and the dilation mask enhancement could go one step further again by restricting that to the pixels we care about most. Note that in this case we probably &lt;em&gt;wouldn’t&lt;&#x2F;em&gt; want to capture the shadow as part of the background as discussed under the “first hurdle” above, since this would effectively be double-counting its impact.&lt;&#x2F;p&gt;
&lt;p&gt;This isn’t a perfect solution by any means, but given that Firefox doesn’t currently consider shadows at all, there’s low-hanging fruit in abundance here. “Perfect” is the enemy of “good”, and even “good” can be the enemy of “a bit better”.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;tl-dr-and-conclusions&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#tl-dr-and-conclusions&quot; aria-label=&quot;Anchor link for: tl-dr-and-conclusions&quot;&gt;TL;DR and conclusions&lt;&#x2F;a&gt;&lt;&#x2F;h2&gt;
&lt;ul&gt;
&lt;li&gt;Contrast checking is a messy problem, both because perceptual factors are messy and because the feature breadth of the web platform throws up so many potential scenarios.&lt;&#x2F;li&gt;
&lt;li&gt;An analytic approach can be useful but has limits, especially when backgrounds get interesting. It can still be used with a worst-case assumption, though, and Lighthouse in particular should almost certainly consider that.&lt;&#x2F;li&gt;
&lt;li&gt;An image-based approach can be much more robust, but coming up with a pass criterion that matches our intuition is challenging, and hacking that function too much risks undermining the generality that was the main benefit.&lt;&#x2F;li&gt;
&lt;li&gt;Combining the two approaches, with a masked image-based background scan supplying an accurate worst-case for an analytic formula, looks to be the pragmatic way forward at this point.&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;I don’t have any immediate plans to take this further, but there are definitely areas that could benefit from more work:&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;Build out the PoC to allow direct parameter tweaking, probably with DOM and canvas side-by-side rather than as alternate modes. Add the ability to tweak more parameters, including &lt;code&gt;font-size&lt;&#x2F;code&gt;, &lt;code&gt;font-weight&lt;&#x2F;code&gt;, &lt;code&gt;font-family&lt;&#x2F;code&gt; and outline mask width. Redesign it as a test suite that could evaluate candidate formulae against a whole batch of scenarios with known preferred outcomes.&lt;&#x2F;li&gt;
&lt;li&gt;Generalize the analytic formula to cover font properties and heterogenous stacked shadows.&lt;&#x2F;li&gt;
&lt;li&gt;Investigate ways to compensate for WCAG’s contrast targets sitting well toward the low end of the scale, with all that implies for averaging.&lt;&#x2F;li&gt;
&lt;li&gt;Design a better analytical model for estimating alpha dilution from blur, or at least a curve fitted to a more extensive sample set.&lt;&#x2F;li&gt;
&lt;li&gt;Look for better pass metrics for assessing image-based contrast results, while remaining wary of over-fitting to a specific outcome.&lt;&#x2F;li&gt;
&lt;li&gt;Investigate more effective and efficient alternatives to increase shadow exposure and reduce shadow dilution, such as an SVG filter applying a dilate followed by a narrow single-pass blur to soften the edges. This would be a two-edged sword since such techniques would pose an even more intractable problem for checkers, but we shouldn’t becomes slaves to &lt;a class=&quot;external&quot; rel=&quot;nofollow noreferrer&quot; href=&quot;https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Goodhart%27s_law&quot;&gt;Goodhart’s law&lt;&#x2F;a&gt;. Ultimately, the goal is to improve legibility for users, not to pass accessibility audits!&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;&lt;em&gt;(End of post)&lt;/em&gt;&lt;/p&gt;</content>
        
    </entry>
    <entry xml:lang="en">
        <title>The problem with Rust&#x27;s `HashMap::entry`</title>
        <published>2025-06-16T00:00:00+00:00</published>
        <updated>2025-06-16T00:00:00+00:00</updated>
        
        <author>
          <name>
            
              Mike Capp
            
          </name>
        </author>
        
        <link rel="alternate" type="text/html" href="https://mrec.github.io/blog/2025/hashmap-entry/"/>
        <id>https://mrec.github.io/blog/2025/hashmap-entry/</id>
        
        <content type="html" xml:base="https://mrec.github.io/blog/2025/hashmap-entry/">&lt;p&gt;This is about a seemingly-minor performance detail that’s niggling at me as a Rust beginner working through the Book. It can have a significant impact in some usage scenarios, it’s a well-known issue, and a well-known workaround exists. It’s just not available in the standard library for stable Rust, and everybody seems weirdly fine with that.&lt;&#x2F;p&gt;
&lt;p&gt;I didn’t really start digging until I was a bit further along in the Book, so the post mentions some concepts (lifetimes, traits) that you might not have encountered yet if you got a bee in your bonnet at the same point I did.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;background&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#background&quot; aria-label=&quot;Anchor link for: background&quot;&gt;Background&lt;&#x2F;a&gt;&lt;&#x2F;h2&gt;
&lt;p&gt;The third exercise in section 8.3 involves collecting employee names grouped by department name, i.e. a &lt;code&gt;HashMap&amp;lt;String, Vec&amp;lt;String&amp;gt;&amp;gt;&lt;&#x2F;code&gt;. The text points to the &lt;code&gt;entry&lt;&#x2F;code&gt; method as the idiomatic way to add or update an entry which might not exist yet, so given a &lt;code&gt;&amp;amp;str&lt;&#x2F;code&gt; key it’s straightforward. (I’m aliasing some types to reduce visual clutter.)&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#ffffff;color:#000000;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#aa2063;&quot;&gt;type &lt;&#x2F;span&gt;&lt;span&gt;V &lt;&#x2F;span&gt;&lt;span style=&quot;color:#0000ff;&quot;&gt;= &lt;&#x2F;span&gt;&lt;span&gt;Vec&amp;lt;String&amp;gt;;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#aa2063;&quot;&gt;type &lt;&#x2F;span&gt;&lt;span&gt;Map &lt;&#x2F;span&gt;&lt;span style=&quot;color:#0000ff;&quot;&gt;= &lt;&#x2F;span&gt;&lt;span&gt;HashMap&amp;lt;String, V&amp;gt;;
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#aa2063;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span style=&quot;color:#7f56c7;&quot;&gt;get_mut_or_insert_default_naive&lt;&#x2F;span&gt;&lt;span&gt;&amp;lt;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#aa2063;&quot;&gt;&amp;#39;a&lt;&#x2F;span&gt;&lt;span&gt;&amp;gt;(map: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#0000ff;&quot;&gt;&amp;amp;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#aa2063;&quot;&gt;&amp;#39;a mut&lt;&#x2F;span&gt;&lt;span&gt; Map, k: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#0000ff;&quot;&gt;&amp;amp;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#aa2063;&quot;&gt;str&lt;&#x2F;span&gt;&lt;span&gt;) -&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#0000ff;&quot;&gt;&amp;amp;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#aa2063;&quot;&gt;&amp;#39;a mut&lt;&#x2F;span&gt;&lt;span&gt; V {
&lt;&#x2F;span&gt;&lt;span&gt;    map.entry(k.to_owned()).or_default()
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;details&gt;
&lt;summary&gt;Is &lt;code&gt;String&lt;&#x2F;code&gt; really the right choice?&lt;&#x2F;summary&gt;
&lt;p&gt;When I did this exercise I was firmly of the opinion that neither department (key) nor employee (value) names should be mutable, and went with &lt;code&gt;Box&amp;lt;str&amp;gt;&lt;&#x2F;code&gt; instead. This has several advantages: it’s guaranteed immutable even if owned by a mutable collection, it’s guaranteed to be right-sized whereas &lt;code&gt;String&lt;&#x2F;code&gt; may have excess capacity for amortized growth, and its memory footprint is smaller by a &lt;code&gt;usize&lt;&#x2F;code&gt; since it doesn’t need to carry a capacity separate from length.&lt;&#x2F;p&gt;
&lt;p&gt;I’m more relaxed about &lt;code&gt;String&lt;&#x2F;code&gt; now; I still think &lt;code&gt;Box&amp;lt;str&amp;gt;&lt;&#x2F;code&gt; is better, I’m just less interested in swimming against the tide. &lt;code&gt;String&lt;&#x2F;code&gt; is less visually noisy, it’s far more common as a basic vocabulary type, it won’t over-allocate capacity unless you actually start futzing with it, and for obvious reasons &lt;code&gt;std&lt;&#x2F;code&gt;’s &lt;code&gt;HashMap&lt;&#x2F;code&gt; won’t give you mutable references to its keys anyway. I’d like any solution I come up with to support &lt;code&gt;Box&amp;lt;str&amp;gt;&lt;&#x2F;code&gt; as well, though. (And I do wish &lt;code&gt;Box&amp;lt;str&amp;gt;&lt;&#x2F;code&gt; had been named &lt;code&gt;String&lt;&#x2F;code&gt; and &lt;code&gt;String&lt;&#x2F;code&gt; had been named &lt;code&gt;StringBuilder&lt;&#x2F;code&gt;, grumble grumble.)&lt;&#x2F;p&gt;
&lt;&#x2F;details&gt;
&lt;details&gt;
&lt;summary&gt;Why do we need to specify the lifetime?&lt;&#x2F;summary&gt;
&lt;p&gt;I was a bit surprised that I needed an explicit &lt;code&gt;&#x27;a&lt;&#x2F;code&gt; lifetime annotation here; I couldn’t see any way a &lt;code&gt;&amp;amp;mut Vec&amp;lt;String&amp;gt;&lt;&#x2F;code&gt; return value could possibly be aliasing a &lt;code&gt;&amp;amp;str&lt;&#x2F;code&gt; parameter, so where’s the ambiguity? But Rust’s lifetime elision rules don’t look at types. If there are two reference parameters and neither of them is &lt;code&gt;self&lt;&#x2F;code&gt;, you have to annotate manually. This isn’t a criticism! Rust faces ongoing struggles with compilation times, a Sufficiently Smart Borrowck is not necessarily a Sufficiently Fast or Stable Borrowck, and adding the lifetime isn’t too onerous.&lt;&#x2F;p&gt;
&lt;&#x2F;details&gt;
&lt;p&gt;This returns a possibly-new &lt;code&gt;&amp;amp;mut V&lt;&#x2F;code&gt; to which you can add a name. But &lt;code&gt;entry&lt;&#x2F;code&gt;’s key parameter has to be a &lt;code&gt;String&lt;&#x2F;code&gt;, rather than the &lt;code&gt;&amp;amp;str&lt;&#x2F;code&gt; you’re holding as you parse input, and  &lt;code&gt;to_owned()&lt;&#x2F;code&gt; is allocating memory on the heap even in the case where the entry already exists and the new key isn’t needed. This is jarring given Rust’s efficiency claims, especially so early on. In the context of this exercise the overhead is irrelevant since we’re being driven by interactive user input, but in a hot loop we’d want to avoid heap allocation if we can.&lt;&#x2F;p&gt;
&lt;p&gt;Does this post represent an absurd level of detail for such a niche issue? Possibly. Is that going to be a running theme for this blog? Almost certainly.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;a class=&quot;external&quot; rel=&quot;nofollow noreferrer&quot; href=&quot;https:&#x2F;&#x2F;xkcd.com&#x2F;386&quot;&gt;&lt;img src=&quot;https:&#x2F;&#x2F;mrec.github.io&#x2F;blog&#x2F;2025&#x2F;hashmap-entry&#x2F;xkcd386_duty_calls_modified.webp&quot; alt=&quot;An XKCD cartoon modified to poke fun at premature optimization&quot; title=&quot;“Oh no, the official XKCD script font TTF is broken! Better raise a bug.”“Wait, weren&amp;#39;t you working through the Rust Book?”“WHAT DOES IT LOOK LIKE I&amp;#39;M DOING?”&quot; &#x2F;&gt;&lt;&#x2F;a&gt;&lt;&#x2F;p&gt;
&lt;h2 id=&quot;first-attempts&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#first-attempts&quot; aria-label=&quot;Anchor link for: first-attempts&quot;&gt;First attempts&lt;&#x2F;a&gt;&lt;&#x2F;h2&gt;
&lt;p&gt;We didn’t have this problem with &lt;code&gt;get&lt;&#x2F;code&gt;. Why could we pass a &lt;code&gt;&amp;amp;str&lt;&#x2F;code&gt; to that but not to &lt;code&gt;entry&lt;&#x2F;code&gt;?&lt;&#x2F;p&gt;
&lt;p&gt;We could pass a reference because there’s no chance that a &lt;code&gt;get&lt;&#x2F;code&gt; call will add a new entry. A &lt;code&gt;HashMap&lt;&#x2F;code&gt; owns its keys, so it needs owned key values when doing that.&lt;&#x2F;p&gt;
&lt;p&gt;We could pass a &lt;code&gt;&amp;amp;str&lt;&#x2F;code&gt; rather than a &lt;code&gt;&amp;amp;String&lt;&#x2F;code&gt; because the method signature is going out of its way to support us, typing its key parameter as a generic &lt;code&gt;&amp;amp;Q&lt;&#x2F;code&gt;, where the map’s key type &lt;code&gt;K&lt;&#x2F;code&gt; is required to implement &lt;code&gt;Borrow&amp;lt;Q&amp;gt;&lt;&#x2F;code&gt;. By implementing &lt;code&gt;Borrow&amp;lt;str&amp;gt;&lt;&#x2F;code&gt;, the &lt;code&gt;String&lt;&#x2F;code&gt; type declares that its data payload is basically just a &lt;code&gt;str&lt;&#x2F;code&gt; and can be borrowed as a &lt;code&gt;&amp;amp;str&lt;&#x2F;code&gt;, and in particular it promises that it’ll hash the same and test for equality the same as a &lt;code&gt;str&lt;&#x2F;code&gt; would. Perfect! In fact, the &lt;a class=&quot;external&quot; rel=&quot;nofollow noreferrer&quot; href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;std&#x2F;borrow&#x2F;trait.Borrow.html&quot;&gt;trait docs&lt;&#x2F;a&gt; for &lt;code&gt;Borrow&lt;&#x2F;code&gt; use &lt;code&gt;HashMap::get&lt;&#x2F;code&gt; as the motivating example.&lt;&#x2F;p&gt;
&lt;p&gt;This doesn’t help us with &lt;code&gt;entry&lt;&#x2F;code&gt;, because of the key ownership requirement. What else could we try? Well, the obvious approach would be to do a &lt;code&gt;get_mut&lt;&#x2F;code&gt; first, and only resort to inserting when we don’t find an existing entry. Unlike &lt;code&gt;entry&lt;&#x2F;code&gt; we’re adding an extra lookup in the insertion case, but the whole point of the optimization we’re attempting is that insertions will be the exception rather than the rule. So:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; data-name=&quot;invalid&quot; style=&quot;background-color:#ffffff;color:#000000;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot; data-name=&quot;invalid&quot;&gt;&lt;span style=&quot;font-style:italic;color:#3c802c;&quot;&gt;&#x2F;&#x2F; doesn&amp;#39;t compile
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#aa2063;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span style=&quot;color:#7f56c7;&quot;&gt;get_mut_or_insert_default_probe1&lt;&#x2F;span&gt;&lt;span&gt;&amp;lt;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#aa2063;&quot;&gt;&amp;#39;a&lt;&#x2F;span&gt;&lt;span&gt;&amp;gt;(map: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#0000ff;&quot;&gt;&amp;amp;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#aa2063;&quot;&gt;&amp;#39;a mut&lt;&#x2F;span&gt;&lt;span&gt; Map, k: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#0000ff;&quot;&gt;&amp;amp;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#aa2063;&quot;&gt;str&lt;&#x2F;span&gt;&lt;span&gt;) -&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#0000ff;&quot;&gt;&amp;amp;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#aa2063;&quot;&gt;&amp;#39;a mut&lt;&#x2F;span&gt;&lt;span&gt; V {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#9062a1;&quot;&gt;match&lt;&#x2F;span&gt;&lt;span&gt; map.get_mut(k) {
&lt;&#x2F;span&gt;&lt;span&gt;        Some(v) &lt;&#x2F;span&gt;&lt;span style=&quot;color:#0000ff;&quot;&gt;=&amp;gt;&lt;&#x2F;span&gt;&lt;span&gt; v,
&lt;&#x2F;span&gt;&lt;span&gt;        None &lt;&#x2F;span&gt;&lt;span style=&quot;color:#0000ff;&quot;&gt;=&amp;gt;&lt;&#x2F;span&gt;&lt;span&gt; map.entry(k.to_owned()).or_default()
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;This doesn’t work. The borrow checker says we’re trying to have two mutable references to the map at the same time. An &lt;code&gt;if let&lt;&#x2F;code&gt; version doesn’t fare any better:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; data-name=&quot;invalid&quot; style=&quot;background-color:#ffffff;color:#000000;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot; data-name=&quot;invalid&quot;&gt;&lt;span style=&quot;font-style:italic;color:#3c802c;&quot;&gt;&#x2F;&#x2F; doesn&amp;#39;t compile
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#aa2063;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span style=&quot;color:#7f56c7;&quot;&gt;get_mut_or_insert_default_probe2&lt;&#x2F;span&gt;&lt;span&gt;&amp;lt;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#aa2063;&quot;&gt;&amp;#39;a&lt;&#x2F;span&gt;&lt;span&gt;&amp;gt;(map: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#0000ff;&quot;&gt;&amp;amp;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#aa2063;&quot;&gt;&amp;#39;a mut&lt;&#x2F;span&gt;&lt;span&gt; Map, k: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#0000ff;&quot;&gt;&amp;amp;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#aa2063;&quot;&gt;str&lt;&#x2F;span&gt;&lt;span&gt;) -&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#0000ff;&quot;&gt;&amp;amp;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#aa2063;&quot;&gt;&amp;#39;a mut&lt;&#x2F;span&gt;&lt;span&gt; V {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#9062a1;&quot;&gt;if &lt;&#x2F;span&gt;&lt;span style=&quot;color:#aa2063;&quot;&gt;let &lt;&#x2F;span&gt;&lt;span&gt;Some(v) &lt;&#x2F;span&gt;&lt;span style=&quot;color:#0000ff;&quot;&gt;=&lt;&#x2F;span&gt;&lt;span&gt; map.get_mut(k) {
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#9062a1;&quot;&gt;return&lt;&#x2F;span&gt;&lt;span&gt; v;
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;    map.entry(k.to_owned()).or_default()
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;In both cases, Rust complains on the first return that &lt;em&gt;“returning this value requires that &lt;code&gt;*map&lt;&#x2F;code&gt; is borrowed for &lt;code&gt;&#x27;a&lt;&#x2F;code&gt;”&lt;&#x2F;em&gt;. Since it’s returning a mutable reference to something in our map (indicated by the lifetime), our map reference is considered to have escaped and be roaming around at large now, and we aren’t allowed to use it again here. It’s frustrating because in both formulations, almost by definition, we’re only trying to use it again in the branch where we &lt;em&gt;didn’t&lt;&#x2F;em&gt; return it the first time! The borrow checker can’t currently track this kind of conditional borrowing; if it sees that we &lt;em&gt;might&lt;&#x2F;em&gt; return a reference, it conservatively assumes we always do.&lt;&#x2F;p&gt;
&lt;p&gt;It turns out that this is a well-known issue. This exact situation became infamous as “Problem Case #3” (which has a nice SCP ring to it) in the epic “non-lexical lifetimes” initiative running from 2017 to 2022. It was deferred from that as being too knotty, but work is ongoing to address it as part of the followup “Polonius” initiative. (I sometimes suspect that &amp;gt;80% of Rust engineer time is spent coming up with clever project names.) A 2024 &lt;a class=&quot;external&quot; rel=&quot;nofollow noreferrer&quot; href=&quot;https:&#x2F;&#x2F;smallcultfollowing.com&#x2F;babysteps&#x2F;blog&#x2F;2024&#x2F;06&#x2F;02&#x2F;the-borrow-checker-within&#x2F;&quot;&gt;blog post&lt;&#x2F;a&gt; by Niko Matsakis reassures us that this work is still progressing.&lt;&#x2F;p&gt;
&lt;p&gt;Note though that even when this work lands, it won’t offer a perfect solution; there’d still be that pesky extra lookup on the insertion path. And it’s not something we can do anything about for now in any case, so it’s time to look elsewhere.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;settling-for-mediocrity&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#settling-for-mediocrity&quot; aria-label=&quot;Anchor link for: settling-for-mediocrity&quot;&gt;Settling for mediocrity&lt;&#x2F;a&gt;&lt;&#x2F;h2&gt;
&lt;p&gt;If we abandon our doomed Utopian dream of avoiding a double lookup in the common case, we can always do this:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#ffffff;color:#000000;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#aa2063;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span style=&quot;color:#7f56c7;&quot;&gt;get_mut_or_insert_default_doublelookup&lt;&#x2F;span&gt;&lt;span&gt;&amp;lt;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#aa2063;&quot;&gt;&amp;#39;a&lt;&#x2F;span&gt;&lt;span&gt;&amp;gt;(map: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#0000ff;&quot;&gt;&amp;amp;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#aa2063;&quot;&gt;&amp;#39;a mut&lt;&#x2F;span&gt;&lt;span&gt; Map, k: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#0000ff;&quot;&gt;&amp;amp;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#aa2063;&quot;&gt;str&lt;&#x2F;span&gt;&lt;span&gt;) -&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#0000ff;&quot;&gt;&amp;amp;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#aa2063;&quot;&gt;&amp;#39;a mut&lt;&#x2F;span&gt;&lt;span&gt; V {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#9062a1;&quot;&gt;if&lt;&#x2F;span&gt;&lt;span&gt; map.contains_key(k) {
&lt;&#x2F;span&gt;&lt;span&gt;        map.get_mut(k).unwrap()
&lt;&#x2F;span&gt;&lt;span&gt;    } &lt;&#x2F;span&gt;&lt;span style=&quot;color:#9062a1;&quot;&gt;else &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;        map.entry(k.to_owned()).or_default()
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;This does have the minor virtue of actually compiling, but otherwise it’s hard to get enthusiastic about it. It’ll come down to a question of whether a usually-redundant allocation is worse than an always-redundant extra lookup. My expectation is yes (don’t worry, we’ll check later) but even at best it would depend heavily on the scenario. It’d be nice to have something a bit more clear-cut.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;going-outside-std&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#going-outside-std&quot; aria-label=&quot;Anchor link for: going-outside-std&quot;&gt;Going outside &lt;code&gt;std&lt;&#x2F;code&gt;&lt;&#x2F;a&gt;&lt;&#x2F;h2&gt;
&lt;p&gt;At this point we’ve gone as far as we can go with the stable &lt;code&gt;std::collections::HashMap&lt;&#x2F;code&gt;. If we want to continue we’ll need to go outside, and discussions around this problem always point to the &lt;a class=&quot;external&quot; rel=&quot;nofollow noreferrer&quot; href=&quot;https:&#x2F;&#x2F;crates.io&#x2F;crates&#x2F;hashbrown&quot;&gt;&lt;code&gt;hashbrown&lt;&#x2F;code&gt; crate&lt;&#x2F;a&gt;. This is what &lt;code&gt;std&lt;&#x2F;code&gt;’s hashmap is built on, and it exposes some additional low-level &lt;code&gt;raw_entry&lt;&#x2F;code&gt; APIs which are tailor-made for us: the &lt;a class=&quot;external&quot; rel=&quot;nofollow noreferrer&quot; href=&quot;https:&#x2F;&#x2F;docs.rs&#x2F;hashbrown&#x2F;0.15.2&#x2F;hashbrown&#x2F;hash_map&#x2F;struct.HashMap.html#method.raw_entry_mut&quot;&gt;docs&lt;&#x2F;a&gt; explicitly mention &lt;em&gt;“Deferring the creation of an owned key until it is known to be required”&lt;&#x2F;em&gt; as a use case. (Although they call that an &lt;em&gt;“exotic situation”&lt;&#x2F;em&gt; which struck me as odd; string-keyed maps are hardly exotic. To quote Ben Elton, that’s like calling a loaf of bread “Enigma”.)&lt;&#x2F;p&gt;
&lt;p&gt;Somewhat ominously, &lt;code&gt;hashbrown&lt;&#x2F;code&gt;’s README describes the &lt;code&gt;RawEntry&lt;&#x2F;code&gt; API as “deprecated”, but as far as I can tell this doesn’t mean anything substantive. The methods aren’t marked as &lt;code&gt;#[deprecated]&lt;&#x2F;code&gt;, and the feature is still included by default. I suspect it’s just a guardrail since stabilization failed, a way to signal that “you shouldn’t assume this will ever be in &lt;code&gt;std&lt;&#x2F;code&gt;”.&lt;&#x2F;p&gt;
&lt;p&gt;Anyway, armed with this, we can do much better:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#ffffff;color:#000000;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#aa2063;&quot;&gt;type &lt;&#x2F;span&gt;&lt;span&gt;BrownMap &lt;&#x2F;span&gt;&lt;span style=&quot;color:#0000ff;&quot;&gt;= &lt;&#x2F;span&gt;&lt;span&gt;hashbrown::HashMap&amp;lt;String, V&amp;gt;;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#aa2063;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span style=&quot;color:#7f56c7;&quot;&gt;get_mut_or_insert_default_hashbrown_raw&lt;&#x2F;span&gt;&lt;span&gt;&amp;lt;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#aa2063;&quot;&gt;&amp;#39;a&lt;&#x2F;span&gt;&lt;span&gt;&amp;gt;(map: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#0000ff;&quot;&gt;&amp;amp;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#aa2063;&quot;&gt;&amp;#39;a mut&lt;&#x2F;span&gt;&lt;span&gt; BrownMap, k: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#0000ff;&quot;&gt;&amp;amp;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#aa2063;&quot;&gt;str&lt;&#x2F;span&gt;&lt;span&gt;) -&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#0000ff;&quot;&gt;&amp;amp;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#aa2063;&quot;&gt;&amp;#39;a mut&lt;&#x2F;span&gt;&lt;span&gt; V {
&lt;&#x2F;span&gt;&lt;span&gt;    map.raw_entry_mut()
&lt;&#x2F;span&gt;&lt;span&gt;        .from_key(k)
&lt;&#x2F;span&gt;&lt;span&gt;        .or_insert_with(|| (k.to_owned(), V::default()))
&lt;&#x2F;span&gt;&lt;span&gt;        .1 &lt;&#x2F;span&gt;&lt;span style=&quot;font-style:italic;color:#3c802c;&quot;&gt;&#x2F;&#x2F; only want the value, not the (mutable, yikes!) key
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Pretty good! No redundant lookups, no redundant allocations. There must be a catch.&lt;&#x2F;p&gt;
&lt;p&gt;Obviously, it’s an extra dependency that mostly just repeats what &lt;code&gt;std&lt;&#x2F;code&gt; already gives you. Even though &lt;code&gt;std&lt;&#x2F;code&gt; uses &lt;code&gt;hashbrown&lt;&#x2F;code&gt; itself, that doesn’t make the dependency “free”. &lt;code&gt;std&lt;&#x2F;code&gt; doesn’t use Cargo to manage its own dependencies, and you aren’t getting &lt;code&gt;std&lt;&#x2F;code&gt; via Cargo anyway, so Cargo doesn’t get to apply its deduplication magic, so you’ll have two copies of the &lt;code&gt;hashbrown&lt;&#x2F;code&gt; code in your binary. It’s not a huge dep, but still.&lt;&#x2F;p&gt;
&lt;p&gt;It also doesn’t help us with the &lt;code&gt;std&lt;&#x2F;code&gt; maps which the vast majority of Rust code will be using. And there isn’t any way to get at &lt;code&gt;std&lt;&#x2F;code&gt;’s more fully-featured underlying map; the use of &lt;code&gt;hashbrown&lt;&#x2F;code&gt; is an implementation detail, and jealously guarded as such. The &lt;code&gt;raw_entry&lt;&#x2F;code&gt; API &lt;em&gt;is&lt;&#x2F;em&gt; currently exposed in nightly Rust’s &lt;code&gt;std&lt;&#x2F;code&gt; behind a feature flag, but a &lt;a class=&quot;external&quot; rel=&quot;nofollow noreferrer&quot; href=&quot;https:&#x2F;&#x2F;github.com&#x2F;rust-lang&#x2F;rust&#x2F;issues&#x2F;56167&quot;&gt;move to stabilize&lt;&#x2F;a&gt; was “closed as not planned” in August 2024 so doesn’t look likely to go anywhere soon.&lt;&#x2F;p&gt;
&lt;details&gt;
&lt;summary&gt;But if &lt;code&gt;std&lt;&#x2F;code&gt;’s map is just a shrinkwrapper, couldn’t we &lt;code&gt;transmute&lt;&#x2F;code&gt; a reference and…?&lt;&#x2F;summary&gt;
&lt;p&gt;&lt;img src=&quot;https:&#x2F;&#x2F;mrec.github.io&#x2F;blog&#x2F;2025&#x2F;hashmap-entry&#x2F;horrified.webp&quot; alt=&quot;cat recoiling in horror&quot; &#x2F;&gt;&lt;&#x2F;p&gt;
&lt;p&gt;No, don’t do that. Yes, it’s a shrinkwrapper, in the sense that &lt;code&gt;std::collections::HashMap&lt;&#x2F;code&gt; is literally a struct with one member &lt;code&gt;base&lt;&#x2F;code&gt; of type &lt;code&gt;hashbrown::HashMap&lt;&#x2F;code&gt;. But you can’t transmute it to the type of &lt;code&gt;base&lt;&#x2F;code&gt;, because you can’t &lt;em&gt;see&lt;&#x2F;em&gt; the type of &lt;code&gt;base&lt;&#x2F;code&gt;. You could transmute it to the type of &lt;em&gt;your&lt;&#x2F;em&gt; &lt;code&gt;hashbrown::HashMap&lt;&#x2F;code&gt;, but &lt;code&gt;std&lt;&#x2F;code&gt; may not be compiling &lt;code&gt;hashbrown&lt;&#x2F;code&gt; with the same flags as you, and everything is going to explode horribly anyway when the versions get out of step. Or, heaven forbid, &lt;code&gt;std&lt;&#x2F;code&gt; switches to a different implementation entirely.&lt;&#x2F;p&gt;
&lt;&#x2F;details&gt;
&lt;p&gt;It’s mentioned less, probably because it’s newer, but &lt;code&gt;hashbrown&lt;&#x2F;code&gt; also offers a much more ergonomic alternative: the &lt;a class=&quot;external&quot; rel=&quot;nofollow noreferrer&quot; href=&quot;https:&#x2F;&#x2F;docs.rs&#x2F;hashbrown&#x2F;0.15.4&#x2F;hashbrown&#x2F;struct.HashMap.html#method.entry_ref&quot;&gt;&lt;code&gt;entry_ref&lt;&#x2F;code&gt;&lt;&#x2F;a&gt; API.&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#ffffff;color:#000000;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#aa2063;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span style=&quot;color:#7f56c7;&quot;&gt;get_mut_or_insert_default_hashbrown_nice&lt;&#x2F;span&gt;&lt;span&gt;(map: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#0000ff;&quot;&gt;&amp;amp;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#aa2063;&quot;&gt;&amp;#39;a mut&lt;&#x2F;span&gt;&lt;span&gt; BrownMap, k: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#0000ff;&quot;&gt;&amp;amp;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#aa2063;&quot;&gt;str&lt;&#x2F;span&gt;&lt;span&gt;) -&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#0000ff;&quot;&gt;&amp;amp;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#aa2063;&quot;&gt;&amp;#39;a mut&lt;&#x2F;span&gt;&lt;span&gt; V {
&lt;&#x2F;span&gt;&lt;span&gt;    map.entry_ref(k).or_default()
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;The chained &lt;code&gt;or_default()&lt;&#x2F;code&gt; method here has an &lt;code&gt;Into&amp;lt;K&amp;gt;&lt;&#x2F;code&gt; bound on &lt;code&gt;&amp;amp;Q&lt;&#x2F;code&gt; (the key reference type) which is how it produces an owned key when needed.&lt;&#x2F;p&gt;
&lt;p&gt;I can’t find any discussion of stabilizing &lt;code&gt;entry_ref&lt;&#x2F;code&gt;, and that isn’t exposed in nightly &lt;code&gt;std&lt;&#x2F;code&gt;. It isn’t even in the &lt;code&gt;hashbrown&lt;&#x2F;code&gt; &lt;a class=&quot;external&quot; rel=&quot;nofollow noreferrer&quot; href=&quot;https:&#x2F;&#x2F;rust-lang.github.io&#x2F;hashbrown&#x2F;hashbrown&#x2F;index.html&quot;&gt;docs&lt;&#x2F;a&gt; hosted under rust-lang.github.io - they’re for an ancient version 0.11.2, way behind the 0.15.4 on crates.io. Is &lt;code&gt;std&lt;&#x2F;code&gt; just vendoring in an old snapshot and never updating?&lt;&#x2F;p&gt;
&lt;h2 id=&quot;does-any-of-this-actually-make-a-difference&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#does-any-of-this-actually-make-a-difference&quot; aria-label=&quot;Anchor link for: does-any-of-this-actually-make-a-difference&quot;&gt;Does any of this actually make a difference?&lt;&#x2F;a&gt;&lt;&#x2F;h2&gt;
&lt;p&gt;Bah, do not pester me with such trifling details.&lt;&#x2F;p&gt;
&lt;p&gt;Well then if you’re going to &lt;em&gt;push&lt;&#x2F;em&gt; me… okay, time for some rough benchmarks. These are very crude – I don’t want to get sidetracked into Criterion.rs just yet, and maybe &lt;code&gt;cargo bench&lt;&#x2F;code&gt; will reach stable before I have to – but I’m inspired by nnethercote’s &lt;a class=&quot;external&quot; rel=&quot;nofollow noreferrer&quot; href=&quot;https:&#x2F;&#x2F;nnethercote.github.io&#x2F;perf-book&#x2F;benchmarking.html&quot;&gt;advice&lt;&#x2F;a&gt; that &lt;em&gt;“Mediocre benchmarking is far better than no benchmarking”&lt;&#x2F;em&gt;. Results are very consistent across multiple timing runs, within a millisecond or two, including with the order reversed. Standard &lt;code&gt;--release&lt;&#x2F;code&gt; build, &lt;code&gt;stable-x86_64-pc-windows-msvc&lt;&#x2F;code&gt; toolchain, AMD Ryzen 7 3700X 3.6 Ghz.&lt;&#x2F;p&gt;
&lt;p&gt;What I’m doing: outside of timing, read in a plaintext copy of Project Gutenberg’s &lt;em&gt;The Complete Works of William Shakespeare&lt;&#x2F;em&gt; and lowercase it. Inside timing, split it into a sequence of word &lt;code&gt;&amp;amp;str&lt;&#x2F;code&gt;s using &lt;a class=&quot;external&quot; rel=&quot;nofollow noreferrer&quot; href=&quot;https:&#x2F;&#x2F;crates.io&#x2F;crates&#x2F;unicode-segmentation&quot;&gt;&lt;code&gt;unicode_segmentation&lt;&#x2F;code&gt;&lt;&#x2F;a&gt;, and use our various &lt;code&gt;get_mut_or_insert_default_*&lt;&#x2F;code&gt; functions to count the number of times each word occurs. Segmentation is fairly expensive, so I also time just the word iteration loop, giving us a baseline above which hashmapping will add overhead. Sample results from each timing are printed out as sanity&#x2F;consistency checks and to prevent things getting optimized away.&lt;&#x2F;p&gt;
&lt;p&gt;This is a scenario which should flatter the experiment: each word appears an average of 34 times, so ~97% of words seen have been seen before, and the actual work done for each appearance after the first is trivial, just incrementing a counter. It’s obviously not meant to represent the full range of real hashmap usage, but it’s real data and doing something at least vaguely interesting. (Did you know Shakespeare never used the word “sausage”? Or “aardvark”.)&lt;&#x2F;p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th style=&quot;text-align: left&quot;&gt;Test&lt;&#x2F;th&gt;&lt;th style=&quot;text-align: right&quot;&gt;Wall time (ms)&lt;&#x2F;th&gt;&lt;th style=&quot;text-align: right&quot;&gt;Over baseline (ms)&lt;&#x2F;th&gt;&lt;&#x2F;tr&gt;&lt;&#x2F;thead&gt;&lt;tbody&gt;
&lt;tr&gt;&lt;td style=&quot;text-align: left&quot;&gt;&lt;code&gt;baseline&lt;&#x2F;code&gt;&lt;&#x2F;td&gt;&lt;td style=&quot;text-align: right&quot;&gt;104&lt;&#x2F;td&gt;&lt;td style=&quot;text-align: right&quot;&gt;-&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td style=&quot;text-align: left&quot;&gt;&lt;code&gt;std_naive&lt;&#x2F;code&gt;&lt;&#x2F;td&gt;&lt;td style=&quot;text-align: right&quot;&gt;200&lt;&#x2F;td&gt;&lt;td style=&quot;text-align: right&quot;&gt;96&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td style=&quot;text-align: left&quot;&gt;&lt;code&gt;std_doublelookup&lt;&#x2F;code&gt;&lt;&#x2F;td&gt;&lt;td style=&quot;text-align: right&quot;&gt;148&lt;&#x2F;td&gt;&lt;td style=&quot;text-align: right&quot;&gt;44&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td style=&quot;text-align: left&quot;&gt;&lt;code&gt;hashbrown_raw&lt;&#x2F;code&gt;&lt;&#x2F;td&gt;&lt;td style=&quot;text-align: right&quot;&gt;118&lt;&#x2F;td&gt;&lt;td style=&quot;text-align: right&quot;&gt;14&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td style=&quot;text-align: left&quot;&gt;&lt;code&gt;hashbrown_nice&lt;&#x2F;code&gt;&lt;&#x2F;td&gt;&lt;td style=&quot;text-align: right&quot;&gt;119&lt;&#x2F;td&gt;&lt;td style=&quot;text-align: right&quot;&gt;15&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;&#x2F;tbody&gt;&lt;&#x2F;table&gt;
&lt;p&gt;That’s… actually more impactful than I expected. Over twice as fast with double lookup, and nearly 7 times as fast with &lt;code&gt;raw_entry_mut&lt;&#x2F;code&gt; or &lt;code&gt;entry_ref&lt;&#x2F;code&gt;.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;tl-dr-and-next-steps&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#tl-dr-and-next-steps&quot; aria-label=&quot;Anchor link for: tl-dr-and-next-steps&quot;&gt;TL;DR and next steps&lt;&#x2F;a&gt;&lt;&#x2F;h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;HashMap::entry&lt;&#x2F;code&gt; can be inefficient when keys are expensive to construct and often repeated&lt;&#x2F;li&gt;
&lt;li&gt;Obvious mitigation is foiled by the dastardly borrow checker for now&lt;&#x2F;li&gt;
&lt;li&gt;Underwhelming mitigation is underwhelming, but not entirely useless&lt;&#x2F;li&gt;
&lt;li&gt;&lt;code&gt;hashbrown&lt;&#x2F;code&gt;’s &lt;code&gt;raw_entry_mut&lt;&#x2F;code&gt; API brings large gains, but is not (nor likely to be) exposed in stable &lt;code&gt;std&lt;&#x2F;code&gt;&lt;&#x2F;li&gt;
&lt;li&gt;&lt;code&gt;hashbrown&lt;&#x2F;code&gt;’s &lt;code&gt;entry_ref&lt;&#x2F;code&gt; API is comparably fast and nicer, but isn’t even on the horizon for &lt;code&gt;std&lt;&#x2F;code&gt;&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;I’d like to try rolling these approaches up into an extension trait to complement the various owned-key methods and genericizing it to cover other applicable owned&#x2F;reference type pairs, not just &lt;code&gt;String&lt;&#x2F;code&gt;&#x2F;&lt;code&gt;&amp;amp;str&lt;&#x2F;code&gt;. (I’d actually done some of this before doing the timings above, but don’t expect it to have affected the results.) This will be mainly a learning exercise in generics and trait design, and maybe a way to get my feet wet publishing to crates.io if it gets that far. This post is long enough already, though, so I’ll punt that to a possible future one. I’d also like to extend the benchmark to find the insert&#x2F;overwrite ratio at which &lt;code&gt;std_doublelookup&lt;&#x2F;code&gt; becomes worth it, and how bad it is in the worst (no overwrites at all) case.&lt;&#x2F;p&gt;
&lt;p&gt;Yes, these are serious intentions. No, I’m definitely not just putting off the dreaded day when I get to the &lt;code&gt;async&lt;&#x2F;code&gt; chapter.&lt;&#x2F;p&gt;
&lt;p&gt;Regardless of outcome, it’s been an educational wander around some of Rust’s moving parts, especially small but important traits like &lt;code&gt;Borrow&lt;&#x2F;code&gt;, the relationship between &lt;code&gt;std&lt;&#x2F;code&gt; and its exploratory implementation crates, and some shadier corners of the borrow checker. I find this sort of magical mystery tour a much stickier way to learn than just reading or staying strictly within the bounds of a given exercise.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;em&gt;(End of post)&lt;/em&gt;&lt;/p&gt;</content>
        
    </entry>
    <entry xml:lang="en">
        <title>Frist psot</title>
        <published>2025-06-11T00:00:00+00:00</published>
        <updated>2025-06-11T00:00:00+00:00</updated>
        
        <author>
          <name>
            
              Mike Capp
            
          </name>
        </author>
        
        <link rel="alternate" type="text/html" href="https://mrec.github.io/blog/2025/frist-psot/"/>
        <id>https://mrec.github.io/blog/2025/frist-psot/</id>
        
        <content type="html" xml:base="https://mrec.github.io/blog/2025/frist-psot/">&lt;p&gt;&lt;em&gt;(Note: this post has since been subsumed into the &lt;a href=&quot;https:&#x2F;&#x2F;mrec.github.io&#x2F;blog&#x2F;about&#x2F;&quot;&gt;about&lt;&#x2F;a&gt; page.)&lt;&#x2F;em&gt;&lt;&#x2F;p&gt;
&lt;p&gt;This blog is a place to put various “notes to self”. Partly as a record of things I’ve found while digging into a topic, partly as a form of &lt;a class=&quot;external&quot; rel=&quot;nofollow noreferrer&quot; href=&quot;https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Rubber_duck_debugging&quot;&gt;rubberducking&lt;&#x2F;a&gt; to clarify my thoughts, and partly as a way to exorcise them from my head when, as is generally the case, they were a distraction from whatever I was supposed to be doing. They’ll generally be byproducts of the learning process, and so aim to be informative rather than groundbreaking. Initially the subject matter will be mostly &lt;a class=&quot;external&quot; rel=&quot;nofollow noreferrer&quot; href=&quot;https:&#x2F;&#x2F;rust-lang.org&#x2F;&quot;&gt;Rust&lt;&#x2F;a&gt;, but who knows what else may creep in later.&lt;&#x2F;p&gt;
&lt;p&gt;For anyone confused by the name of the blog, it’s a reference to &lt;a class=&quot;external&quot; rel=&quot;nofollow noreferrer&quot; href=&quot;https:&#x2F;&#x2F;seths.blog&#x2F;2005&#x2F;03&#x2F;dont_shave_that&#x2F;&quot;&gt;yak shaving&lt;&#x2F;a&gt; with a side allusion to a promotional slogan (“Never Knowingly Undersold”) used by a UK retail chain. Yak shaving is very much going to be the theme here; being free to pursue those temptingly hirsute bovines wherever they may roam, razor glinting keenly in the crisp clean air of the open steppe.&lt;&#x2F;p&gt;
&lt;p&gt;The format is going to be fairly minimalistic. I love the concept and values of the &lt;a class=&quot;external&quot; rel=&quot;nofollow noreferrer&quot; href=&quot;https:&#x2F;&#x2F;briankoberlein.com&#x2F;tech&#x2F;quiet-web&#x2F;&quot;&gt;quiet web&lt;&#x2F;a&gt;, and my ideal design for a webpage looks suspiciously like Reader View but with slightly more yaks. There will be absolutely no ads, trackers, analytics, cookies, or JavaScript. Anything that’s not subject matter should stay out of the way as far as possible.&lt;&#x2F;p&gt;
&lt;p&gt;I do like HTML’s newish &lt;code&gt;&amp;lt;details&amp;gt;&lt;&#x2F;code&gt; element as a way to capture optional digressions without breaking the flow of the main topic. I think of these as sub-yaks, fractally budding from the Great Universal Mandelyak.&lt;&#x2F;p&gt;
&lt;p&gt;The header image had as its starting point &lt;a class=&quot;external&quot; rel=&quot;nofollow noreferrer&quot; href=&quot;https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;File:Sarlyk_Yak2.jpg&quot;&gt;this fine photograph&lt;&#x2F;a&gt; by Alexandr Frolov, whose &lt;a class=&quot;external&quot; rel=&quot;nofollow noreferrer&quot; href=&quot;https:&#x2F;&#x2F;commons.wikimedia.org&#x2F;wiki&#x2F;User:Alexandr_frolov&quot;&gt;user page&lt;&#x2F;a&gt; has a badge to show that he owns a camel. The rest of us are wasting our lives.&lt;&#x2F;p&gt;
&lt;p&gt;It’s been through a lot of changes though. (The image, not the camel.) That yak has seen things.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;em&gt;(End of post)&lt;/em&gt;&lt;/p&gt;</content>
        
    </entry>
</feed>